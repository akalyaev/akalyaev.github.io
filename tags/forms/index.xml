<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Forms on Home on Rails</title>
    <link>http://homeonrails.com/tags/forms/index.xml</link>
    <description>Recent content in Forms on Home on Rails</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>All rights reserved - 2017</copyright>
    <atom:link href="http://homeonrails.com/tags/forms/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>AssociationCountValidator</title>
      <link>http://homeonrails.com/2012/10/associationcountvalidator/</link>
      <pubDate>Wed, 10 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>http://homeonrails.com/2012/10/associationcountvalidator/</guid>
      <description>&lt;p&gt;As a result of my &lt;a href=&#34;http://homeonrails.com/2012/10/validating-nested-associations-in-rails&#34;&gt;previous blog post&lt;/a&gt;
about validating nested associations, I wrote custom validator for Rails 3.
It is intended to help you to validate records count in a given association.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# lib/association_count_validator.rb
class AssociationCountValidator &amp;lt; ActiveModel::Validations::LengthValidator
  MESSAGES = { :wrong_length =&amp;gt; :association_count_invalid,
               :too_short =&amp;gt; :association_count_greater_than_or_equal_to,
               :too_long =&amp;gt; :association_count_less_than_or_equal_to }.freeze

  def initialize(options)
    MESSAGES.each { |key, message| options[key] ||= message }
    super
  end

  def validate_each(record, attribute, value)
    existing_records = record.send(attribute).reject(&amp;amp;:marked_for_destruction?)
    super(record, attribute, existing_records)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Probably, you noticed that this is just a wrapper over the standard &lt;code&gt;LengthValidator&lt;/code&gt;.
This has a big advantage - all options, provided by the basic validator, are supported.
And it correctly handles the situation with marked for destruction records,
which was mentioned in the previous post.&lt;/p&gt;

&lt;p&gt;Usage:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Company &amp;lt; ActiveRecord::Base
  OFFICES_COUNT_MIN = 1

  attr_accessible :name, :offices_attributes

  validates :name, presence: true
  validates :offices, association_count: { minimum: OFFICES_COUNT_MIN }

  has_many :offices, inverse_of: :company

  accepts_nested_attributes_for :offices, allow_destroy: true
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Do not forget to add custom error messages to your localization files.&lt;/p&gt;

&lt;p&gt;Example for &lt;code&gt;en&lt;/code&gt; culture:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;en:
  errors:
    messages:
      association_count_less_than_or_equal_to:
        one: count must be less than 1
        other: count must be less than or equal to %{count}
      association_count_greater_than_or_equal_to:
        one: count must be greater than 1
        other: count must be greater than or equal to %{count}
      association_count_invalid:
        one: count is invalid (must be equal to 1)
        other: count is invalid (must be equal to %{count})
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Validating nested associations in Rails</title>
      <link>http://homeonrails.com/2012/10/validating-nested-associations-in-rails/</link>
      <pubDate>Mon, 08 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>http://homeonrails.com/2012/10/validating-nested-associations-in-rails/</guid>
      <description>&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;Rails provide a wide range of options for creating rich forms for your models.
This can be a simple form for one object, or the form for many related objects.
Usually it is a parent-children relations. If you are not familiar with such terms
as &lt;a href=&#34;http://api.rubyonrails.org/classes/ActionView/Helpers/FormHelper.html#M001605&#34;&gt;form_for&lt;/a&gt;
or &lt;a href=&#34;http://api.rubyonrails.org/classes/ActiveRecord/NestedAttributes/ClassMethods.html#M002132&#34;&gt;accepts_nested_attributes_for&lt;/a&gt;,
I strongly recommend taking a look at this article &lt;a href=&#34;http://rubysource.com/complex-rails-forms-with-nested-attributes/&#34;&gt;Complex Rails Forms with Nested Attributes&lt;/a&gt;,
written by &lt;a href=&#34;http://xaviershay.com/&#34;&gt;Xavier Shay&lt;/a&gt;, which will show your how you can create complex forms with Rails.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;an-example&#34;&gt;An example&lt;/h2&gt;

&lt;p&gt;Suppose, we have a model called &lt;code&gt;Company&lt;/code&gt;. And the company may have several offices.
Lets define these two models.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Company &amp;lt; ActiveRecord::Base
  attr_accessible :name, :offices_attributes
  validates :name, presence: true
  has_many :offices
  accepts_nested_attributes_for :offices, allow_destroy: true
end

class Company::Office &amp;lt; ActiveRecord::Base
  attr_accessible :company_id, :name
  validates :name, presence: true
  belongs_to :company
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both company and office have names. The company could have zero or more offices.&lt;/p&gt;

&lt;p&gt;By including &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt; it becomes possible to access
offices attributes inside our &lt;code&gt;Company&lt;/code&gt; model.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; c = Company.create(name: &#39;Mars LLC&#39;)
&amp;gt;   =&amp;gt; #&amp;lt;Company id: 1, name: &amp;quot;Mars LLC&amp;quot;, created_at: &amp;quot;2012-10-08 19:16:44&amp;quot;, updated_at: &amp;quot;2012-10-08 19:16:44&amp;quot;&amp;gt;

# add two new offices
&amp;gt; c.offices_attributes = [{ name: &#39;North America&#39; }, { name: &#39;Europe&#39; }]
&amp;gt;   =&amp;gt; [{:name=&amp;gt;&amp;quot;North America&amp;quot;}, {:name=&amp;gt;&amp;quot;Europe&amp;quot;}]
&amp;gt; c.save
&amp;gt; c.offices
&amp;gt;   =&amp;gt; [#&amp;lt;Company::Office id: 1, company_id: 1, name: &amp;quot;North America&amp;quot;, created_at: &amp;quot;2012-10-08 19:21:54&amp;quot;, updated_at: &amp;quot;2012-10-08 19:21:54&amp;quot;&amp;gt;, #&amp;lt;Company::Office id: 2, company_id: 1, name: &amp;quot;Europe&amp;quot;, created_at: &amp;quot;2012-10-08 19:21:54&amp;quot;, updated_at: &amp;quot;2012-10-08 19:21:54&amp;quot;&amp;gt;]

# edit office in North America
&amp;gt; c.offices_attributes = [{ id: 1, name: &amp;quot;North America (it&#39;s cold out there)&amp;quot; }]
&amp;gt;   =&amp;gt; [{:id=&amp;gt;1, :name=&amp;gt;&amp;quot;North America (it&#39;s cold out there)&amp;quot;}]
&amp;gt; c.save
&amp;gt; c.offices
&amp;gt;   =&amp;gt; [#&amp;lt;Company::Office id: 1, company_id: 1, name: &amp;quot;North America (it&#39;s cold out there)&amp;quot;, created_at: &amp;quot;2012-10-08 19:21:54&amp;quot;, updated_at: &amp;quot;2012-10-08 19:25:18&amp;quot;&amp;gt;, #&amp;lt;Company::Office id: 2, company_id: 1, name: &amp;quot;Europe&amp;quot;, created_at: &amp;quot;2012-10-08 19:21:54&amp;quot;, updated_at: &amp;quot;2012-10-08 19:21:54&amp;quot;&amp;gt;]

# delete an office in Europe
&amp;gt; c.offices_attributes = [{ id: 2, _destroy: &#39;1&#39; }]
&amp;gt;   =&amp;gt; [{:id=&amp;gt;2, :_destroy=&amp;gt;&amp;quot;1&amp;quot;}]
&amp;gt; c.save
&amp;gt; c.offices
&amp;gt;   =&amp;gt; [#&amp;lt;Company::Office id: 1, company_id: 1, name: &amp;quot;North America (it&#39;s cold out there)&amp;quot;, created_at: &amp;quot;2012-10-08 19:21:54&amp;quot;, updated_at: &amp;quot;2012-10-08 19:25:18&amp;quot;&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two basic options, that you should know when dealing with &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;allow_destroy&lt;/code&gt; - allows to destroy objects (&lt;code&gt;false&lt;/code&gt; by default)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reject_if&lt;/code&gt; - rejects the records, based on the given  &lt;code&gt;Proc&lt;/code&gt; or
a &lt;code&gt;Symbol&lt;/code&gt; pointing to a method. This one is simular to the &lt;code&gt;Enumerable::reject&lt;/code&gt; method (&lt;a href=&#34;http://www.ruby-doc.org/core-1.9.3/Enumerable.html#method-i-reject&#34;&gt;Doc&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Take a look at the other supported options on &lt;a href=&#34;http://apidock.com/rails/ActiveRecord/NestedAttributes/ClassMethods/accepts_nested_attributes_for&#34;&gt;apidock.com&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;validating-nested-attributes&#34;&gt;Validating nested attributes&lt;/h3&gt;

&lt;p&gt;Except the basic validation, you can use &lt;code&gt;reject_if&lt;/code&gt; option to validate a nested object.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Company &amp;lt; ActiveRecord::Base
  attr_accessible :name, :offices_attributes
  validates :name, presence: true
  has_many :offices
  accepts_nested_attributes_for :offices, allow_destroy: true, reject_if: :office_name_invalid

  private

    def office_name_invalid(attributes)
      # office name shouldn&#39;t start with underscore
      attributes[&#39;name&#39;] =~ /\A_/
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The method should return either true (rejects the record) or false.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; c.offices_attributes = [{ id: 1, name: &#39;_North America&#39;}]
&amp;gt;   =&amp;gt; [{:id=&amp;gt;1, :name=&amp;gt;&amp;quot;_North America&amp;quot;}]
&amp;gt; c.save
&amp;gt; c.offices # no changes
&amp;gt;   =&amp;gt; [#&amp;lt;Company::Office id: 1, company_id: 1, name: &amp;quot;North America&amp;quot;, created_at: &amp;quot;2012-10-08 19:21:54&amp;quot;, updated_at: &amp;quot;2012-10-08 19:46:22&amp;quot;&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could use predefined &lt;code&gt;:all_blank&lt;/code&gt; symbol.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; c.offices_attributes = [{ name: &#39;&#39;}]
&amp;gt;   =&amp;gt; [{:name=&amp;gt;&amp;quot;&amp;quot;}]
&amp;gt; c.save
&amp;gt; c.offices # no changes
&amp;gt;   =&amp;gt; [#&amp;lt;Company::Office id: 1, company_id: 1, name: &amp;quot;North America&amp;quot;, created_at: &amp;quot;2012-10-08 19:21:54&amp;quot;, updated_at: &amp;quot;2012-10-08 19:46:22&amp;quot;&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Passing &lt;code&gt;:all_blank&lt;/code&gt; instead of a Proc will create a proc that will reject a record where all the attributes are blank excluding any value for &lt;code&gt;_destroy&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;validating-count-of-the-nested-attributes&#34;&gt;Validating count of the nested attributes&lt;/h3&gt;

&lt;p&gt;Lets add more complexity to our company model and say for example: it &lt;strong&gt;must have at least one
office&lt;/strong&gt; (we usually called it the main office).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Company &amp;lt; ActiveRecord::Base
  OFFICES_COUNT_MIN = 1

  attr_accessible :name, :offices_attributes
  validates :name, presence: true
  validate do
    check_offices_number
  end
  has_many :offices
  accepts_nested_attributes_for :offices, allow_destroy: true

  private

    def offices_count_valid?
      offices.count &amp;gt;= OFFICES_COUNT_MIN
    end

    def check_offices_number
      unless offices_count_valid?
        errors.add(:base, :offices_too_short, :count =&amp;gt; OFFICES_COUNT_MIN)
      end
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem here is that accepts_nested_attributes_for call destroy for child
objects &lt;strong&gt;AFTER&lt;/strong&gt; validation of the parent object. So the user is able to delete
an office. Of course, later, when the user will try to edit a company,
he/she will get an error - &amp;ldquo;Company should have at least one office.&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://homeonrails.com/images/posts/2012-10-08-validating-nested-associations-in-rails/flowchart.png&#34; alt=&#34;Flowchart of the validation process&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; c.offices_attributes = [{ id: 1, _destroy: &#39;1&#39; }]
&amp;gt;   =&amp;gt; [{:id=&amp;gt;1, :_destroy=&amp;gt;&amp;quot;1&amp;quot;}]
&amp;gt; c.save
&amp;gt; c.offices
&amp;gt;   =&amp;gt; []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You could try to use standard &lt;code&gt;length&lt;/code&gt; validator
(e.g. &lt;code&gt;validates :offices, length: { minimum: OFFICES_COUNT_MIN }&lt;/code&gt;), and it actually works,
but again, it does not take into account the fact that some of the records may
be marked for destruction.&lt;/p&gt;

&lt;p&gt;The things are getting a little tricky here.
To sort out the problem, we need to understand what &lt;code&gt;offices_attributes=&lt;/code&gt; method does.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# accepts_nested_attributes_for generates for us this method
def offices_attributes=(attributes)
  # @note the name of the method to call may vary depending on the type of association
  # @see https://github.com/rails/rails/blob/master/activerecord/lib/active_record/nested_attributes.rb#L285
  assign_nested_attributes_for_collection_association(:offices, attributes, mass_assignment_options)
end

def assign_nested_attributes_for_collection_association
  ...
  if !call_reject_if(association_name, attributes) # if the record passed
    # update a record with the attributes or marks it for destruction
    assign_to_or_mark_for_destruction(existing_record, attributes, options[:allow_destroy], assignment_opts)
  end
  ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see from the code above, our method marks offices records (with &lt;code&gt;_destroy&lt;/code&gt; attribute) for destruction.
When the company validates offices count, the offices relation includes &lt;strong&gt;all&lt;/strong&gt; the records.
So, all we need to do is to select only those records not marked for destruction.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Company &amp;lt; ActiveRecord::Base
  ...

  private

    def offices_count_valid?
      offices.reject(&amp;amp;:marked_for_destruction?).count &amp;gt;= OFFICES_COUNT_MIN
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we&amp;rsquo;ve got the actual number of the company&amp;rsquo;s offices. Therefore, we will get an error while trying to delete the last office in North America:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; c.offices_attributes = [{ id: 1, _destroy: &#39;1&#39; }]
&amp;gt;   =&amp;gt; [{:id=&amp;gt;1, :_destroy=&amp;gt;&amp;quot;1&amp;quot;}]
&amp;gt; c.save
&amp;gt; c.errors
&amp;gt;   =&amp;gt; #&amp;lt;ActiveModel::Errors:0x000000038fc840 @base=#&amp;lt;Company id: 1, name: &amp;quot;Mars LLC&amp;quot;, created_at: &amp;quot;2012-10-08 19:16:44&amp;quot;, updated_at: &amp;quot;2012-10-08 19:16:44&amp;quot;&amp;gt;, @messages={:base=&amp;gt;[&amp;quot;Company should have at least one office.&amp;quot;]}&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hopefully, in Rails 3 we are now able to write our own custom validators, so I&amp;rsquo;ve added &lt;a href=&#34;http://homeonrails.com/2012/10/associationcountvalidator&#34;&gt;one more for this case&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you know a better solution, don&amp;rsquo;t hesitate to &lt;a href=&#34;http://homeonrails.com/about.html&#34;&gt;contact me&lt;/a&gt; or simply leave a comment below.&lt;/p&gt;

&lt;h3 id=&#34;validating-presence-of-the-parent-object&#34;&gt;Validating presence of the parent object&lt;/h3&gt;

&lt;p&gt;The last thing I wanna share with you is how you can add &lt;code&gt;presence&lt;/code&gt; validator
to the parent association inside the nested model.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Company::Office &amp;lt; ActiveRecord::Base
  attr_accessible :company_id, :name

  validates :name, presence: true
  # add validator to company
  validates :company, presence: true

  belongs_to :company
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We want to be sure that the office always have a corresponding company. But this fails on creating a company.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; c = Company.create(name: &#39;Adidas America Inc&#39;, offices_attributes: [{ name: &#39;LS&#39; }])
&amp;gt;   =&amp;gt; #&amp;lt;Company id: nil, name: &amp;quot;Adidas America Inc&amp;quot;, created_at: nil, updated_at: nil&amp;gt;
&amp;gt; c.errors
&amp;gt;   =&amp;gt; #&amp;lt;ActiveModel::Errors:0x000000036387a8 @base=#&amp;lt;Company id: nil, name: &amp;quot;Adidas America Inc&amp;quot;, created_at: nil, updated_at: nil&amp;gt;, @messages={:&amp;quot;offices.company&amp;quot;=&amp;gt;[&amp;quot;can&#39;t be blank&amp;quot;]}&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The solution here is to use &lt;code&gt;inverse_of&lt;/code&gt; option. See the options section
in &lt;code&gt;belongs_to&lt;/code&gt;, &lt;code&gt;has_one&lt;/code&gt; or &lt;code&gt;has_many&lt;/code&gt; &lt;a href=&#34;http://apidock.com/rails/ActiveRecord/Associations/ClassMethods/belongs_to&#34;&gt;documentation&lt;/a&gt;.
Note: it does not work in combination with the &lt;code&gt;polymorphic&lt;/code&gt; option.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Company &amp;lt; ActiveRecord::Base
  ...
  has_many :offices, inverse_of: :company
  ...
end

class Company::Office &amp;lt; ActiveRecord::Base
  ...
  belongs_to :company, inverse_of: :offices
  ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we are able to create a company instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; c = Company.create(name: &#39;Adidas America Inc&#39;, offices_attributes: [{ name: &#39;LS&#39; }])
&amp;gt;   =&amp;gt; #&amp;lt;Company id: 2, name: &amp;quot;Adidas America Inc&amp;quot;, created_at: &amp;quot;2012-10-09 07:36:07&amp;quot;, updated_at: &amp;quot;2012-10-09 07:36:07&amp;quot;&amp;gt;
&amp;gt; c.offices
&amp;gt;   =&amp;gt; #&amp;lt;Company::Office id: 6, company_id: 2, name: &amp;quot;LS&amp;quot;, created_at: &amp;quot;2012-10-09 07:36:07&amp;quot;, updated_at: &amp;quot;2012-10-09 07:36:07&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>