<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ruby On Rails on Home on Rails</title>
    <link>http://homeonrails.com/tags/ruby-on-rails/index.xml</link>
    <description>Recent content in Ruby On Rails on Home on Rails</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>All rights reserved - 2017</copyright>
    <atom:link href="http://homeonrails.com/tags/ruby-on-rails/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Shamrock</title>
      <link>http://homeonrails.com/2015/02/shamrock/</link>
      <pubDate>Tue, 17 Feb 2015 10:05:37 +0000</pubDate>
      
      <guid>http://homeonrails.com/2015/02/shamrock/</guid>
      <description>&lt;p&gt;Бывают случаи, когда WebMock&amp;rsquo;а недостаточно, или же вы просто не любите stub&amp;rsquo;ы
и хотите, чтобы тест делал реальный http запрос. В таких случаях вы можете
написать свой &lt;a href=&#34;https://practicingruby.com/articles/implementing-an-http-file-server&#34;&gt;простенький http
сервер&lt;/a&gt;
или выбрать один из существующих, и стартовать его на время тестов(а). А можно
взять готовую библиотеку - &lt;a href=&#34;https://github.com/jsl/shamrock&#34;&gt;Shamrock&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Она принимает на вход любое Rack приложение и запускает его в отдельном треде с
помощью WEBrick&amp;rsquo;а. Порт можно задать самому. В противном случае будет
использован первый свободный.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def setup
  json = load_fixture(&amp;quot;service/200.json&amp;quot;)
  my_rack_app = proc {|env| [200, {&amp;quot;Content-Type&amp;quot; =&amp;gt; &amp;quot;application/json&amp;quot;}, [json]]}
  @service = Shamrock::Service.new(my_rack_app)
  @service.start
  @service.uri    # =&amp;gt; #&amp;lt;URI::HTTP http://localhost:54321&amp;gt;
end

def teardown
  @service.stop
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Доступные параметры у Service#new:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;handler&lt;/code&gt; - обработчик, который запускает Rack приложение (по умолчанию Rack::Handler::WEBrick)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;port&lt;/code&gt; - порт&lt;/li&gt;
&lt;li&gt;&lt;code&gt;monitor&lt;/code&gt; - монитор, который блокируется до тех пор, пока сервер не стартанет&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Вообще, либа написана хорошо, и выполняет именно то, что от нее ждут. Правда
популярности ей это не принесло :)&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fast Rails API</title>
      <link>http://homeonrails.com/2014/03/fast-rails-api/</link>
      <pubDate>Sun, 09 Mar 2014 13:00:00 +0000</pubDate>
      
      <guid>http://homeonrails.com/2014/03/fast-rails-api/</guid>
      <description>&lt;p&gt;Here are the slides from my internal talk, which I recently gave for my
colleagues.&lt;/p&gt;

&lt;p&gt;They are showing the history of optimizing Rails API, starting from AR connections pool and
ending by using Fragment caching. Also there is list of tools for
profiling applications (stackprof, etc.). All techniques are quite
famous.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;script async=&#34;true&#34; class=&#34;speakerdeck-embed&#34; data-id=&#34;b618391085100131b8c566a463623da4&#34; data-ratio=&#34;1.33333333333333&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;       &lt;/script&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2 id=&#34;what-we-ve-tried&#34;&gt;What we&amp;rsquo;ve tried&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Connection pool

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://devcenter.heroku.com/articles/concurrency-and-database-connections&#34;&gt;Concurrency and Database Connections in Ruby with ActiveRecord&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rails-api/rails-api&#34;&gt;Rails-api&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Do not load &lt;code&gt;rails/all&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Establish DB connection after fork/new thread was created&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kzk/unicorn-worker-killer&#34;&gt;Unicorn worker killer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Postgresql tuning

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://postgresql.leopard.in.ua/html/&#34;&gt;Работа с PostgreSQL: настройка и масштабирование Алексея Васильева&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://momjian.us/main/writings/pgsql/hw_performance/&#34;&gt;PostgreSQL Hardware Performance Tuning by Bruce Momjian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://raghavt.blogspot.ru/2012/04/caching-in-postgresql.html&#34;&gt;Caching in PostgreSQL&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Rails 4&lt;/li&gt;
&lt;li&gt;Ruby 2.1.0&lt;/li&gt;
&lt;li&gt;Fragment caching

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://devcenter.heroku.com/articles/caching-strategies&#34;&gt;Caching Strategies for Rails&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://signalvnoise.com/posts/3113-how-key-based-cache-expiration-works&#34;&gt;How key-based cache expiration works&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rails-api/active_model_serializers&#34;&gt;Active Model Serializers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ohler55/oj&#34;&gt;Oj&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Do not instantiate AR objects

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://brainspec.com/blog/2012/09/28/lightning-json-in-rails/&#34;&gt;Lightning JSON in Rails&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Try &lt;a href=&#34;https://github.com/tmm1/gctools&#34;&gt;OOBGC - Out-of-Band GC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Try different web server (e.g. Puma)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If we missed something, please share your ideas in comments.&lt;/p&gt;

&lt;h2 id=&#34;profiling-tools&#34;&gt;Profiling tools&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/tmm1/stackprof&#34;&gt;Stackprof&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/miniprofiler/rack-mini-profiler&#34;&gt;Rack Mini Profiler&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/flyerhzm/bullet&#34;&gt;Bullet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/wvanbergen/request-log-analyzer&#34;&gt;Request log analyzer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://newrelic.com/&#34;&gt;NewRelic&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;On the penultimate slide is the title slide of the &lt;a href=&#34;http://www.slideshare.net/maxlapshin/rails-26416461&#34;&gt;presentation&lt;/a&gt; of Max
Lapshin, which briefly tells that to solve certain problems (such as when you need to
keep a large number of clients) more appropriate solution might be using
another technologies/languages (Erlang in particular).&lt;/p&gt;

&lt;p&gt;UPD. Ideas from comments&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Try &lt;a href=&#34;http://api.rubyonrails.org/classes/ActionController/ConditionalGet.html&#34;&gt;Conditional Get&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>Don&#39;t do this at home on Rails #3</title>
      <link>http://homeonrails.com/2013/01/dont-do-this-at-home-on-rails-3/</link>
      <pubDate>Sat, 05 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>http://homeonrails.com/2013/01/dont-do-this-at-home-on-rails-3/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;Languages: Ruby&lt;/li&gt;
&lt;li&gt;Difficulty: &lt;span class=&#34;label label-success&#34;&gt;Easy&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A lot of time has passed since my last post, so I decided to fix this
little drawback. Next, we will discuss three small pieces of code,
which smells not very good. Let&amp;rsquo;s see what we can do about it.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;1-vulnerabilities-in-code&#34;&gt;#1 - Vulnerabilities in code&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s take a closer look at two methods from the controller:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def show_with_fragments
  constant = get_constant_from_param
  if constant
    obj = constant.find(params[:id])
    data = obj.attributes
    data.merge!(:telecasts =&amp;gt; obj.telecasts.map(&amp;amp;:as_json)) if obj.is_a?(TvShow::Programme)
    data.merge!(:seasons =&amp;gt; obj.seasons.map(&amp;amp;:as_json)) if obj.is_a?(TvShow::Serial)
    render :json =&amp;gt; data
  else
    render :json =&amp;gt; {}
  end
end

private

def get_constant_from_param(type = nil)
  param = type || params[:type]
  begin
    constant = param.constantize
    constant if constant &amp;lt; ActiveRecord::Base
  rescue NameError
    nil
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, what happens here?&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We receive the type of the model (&lt;code&gt;params[:type]&lt;/code&gt;) and convert string
to a constant using &lt;a href=&#34;http://apidock.com/rails/v3.2.8/ActiveSupport/Inflector/constantize&#34;&gt;constantize&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;We find the record with a given id (&lt;code&gt;params[:id]&lt;/code&gt;) and select all its
attributes and attributes of the associated objects.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We expect that the &lt;code&gt;type&lt;/code&gt; will be either &amp;ldquo;TvShow::Programme&amp;rdquo; or &amp;ldquo;TvShow::Serial&amp;rdquo;.
But what if &lt;code&gt;type&lt;/code&gt; will be &amp;ldquo;User&amp;rdquo;. We will get access to all the attributes of the
&lt;code&gt;User&lt;/code&gt; model. This is a serious security issue in our application.&lt;/p&gt;

&lt;p&gt;The first step is to limit &lt;code&gt;type&lt;/code&gt; to the &lt;code&gt;TvShow&lt;/code&gt; class descendants only.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def show_with_fragments
  constant = get_constant_from_param
  unless constant.is_a?(TvShow)
    raise ArgumentError, “type should be TvShow class descendant”
  end
  if constant
    obj = constant.find(params[:id])
    data = obj.attributes
    data.merge!(:telecasts =&amp;gt; obj.telecasts.map(&amp;amp;:as_json)) if obj.is_a?(TvShow::Programme)
    data.merge!(:seasons =&amp;gt; obj.seasons.map(&amp;amp;:as_json)) if obj.is_a?(TvShow::Serial)
    render :json =&amp;gt; data
  else
    render :json =&amp;gt; {}
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above violates &lt;a href=&#34;http://en.wikipedia.org/wiki/Open/closed_principle&#34;&gt;OCP&lt;/a&gt;
principe. Because we want to take advantage of polymorphism,
lets move the logic of getting the attributes of associated
objects into the classes themselves (see &lt;code&gt;complete_attributes_json&lt;/code&gt; method).
This will allow us to remove all those ugly is_a? checks.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def show_with_fragments
  constant = get_constant_from_param
  unless constant.is_a?(TvShow)
    raise ArgumentError, “type param should be TvShow accessor class”
  end
  if constant
    obj = constant.find(params[:id])
    render :json =&amp;gt; obj.complete_attributes_json
  else
    render :json =&amp;gt; {}
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looks better, right?&lt;/p&gt;

&lt;h3 id=&#34;2-take-advantage-of-yaml-language&#34;&gt;#2 - Take advantage of YAML language&lt;/h3&gt;

&lt;p&gt;Despite the fact that most of rails applications (and others) using
&lt;a href=&#34;http://en.wikipedia.org/wiki/YAML&#34;&gt;YAML&lt;/a&gt; to store the translations and settings,
not many of us knows all its features. Two features that
distinguish YAML from the capabilities of other data serialization languages
​​are Relational trees and Data Typing. The most interesting is the first one.
It allows us to attach the anchors (&amp;amp;) on the elements and refer to them
using references (*). To understand this, it is useful to imagine
a document as a tree.&lt;/p&gt;

&lt;p&gt;For example, here is some common locale file &lt;code&gt;config/locales/en.yml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;en:
  helpers:
    submit:
      product:
        create: &#39;Create it&#39;
        update: &#39;Save it&#39;
      product_item:
        create: &#39;Create it&#39;
        update: &#39;Save it&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What if we could define the translations for helpers &lt;code&gt;create&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt;
in one place, and then use them in other cases. Usually these translations
rarely changes, so, in this case, this is just what we need.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;en:
  helpers:
    submit:
      product:
        create: &amp;amp;create &#39;Create it&#39;
        update: &amp;amp;update &#39;Save it&#39;
      product_item:
        create: *create
        update: *update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have created two anchors and referred to them inside product_item
through two links. Advantages: avoiding possible errors (define
in one place) and compactness. Also, in future, if the translation will needs
to be changed, we wont spend much time to perform the appropriate changes.&lt;/p&gt;

&lt;p&gt;You can anchor not only tree nodes, but also the whole branches:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;common: &amp;amp;COMMON
  adapter: postgresql
  encoding: unicode
  pool: 10

development:
  &amp;lt;&amp;lt;: *COMMON
  database: db_name
  username: postgres
  password:
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-look-for-existing-method-before-writing-your-own&#34;&gt;#3 - Look for existing method before writing your own&lt;/h3&gt;

&lt;p&gt;Maybe I&amp;rsquo;m repeating myself, but this is exactly the case where repetition
will only benefit.&lt;/p&gt;

&lt;p&gt;Before you write any functionality, that is not relevant to the
application&amp;rsquo;s business logic, it is always better to look, maybe someone
has already implemented it. And very often it is. All we are know the
advantages of using existing solutions (libraries). And I think, if you like
it (you can not see any obstacles - performance, memory, that can stop you),
it is better to use it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def keys_to_symbols(data)
  res = {}
  data.each do |k, v|
    res[k.to_sym] = v.is_a?(Hash) ? keys_to_symbols(v) : v
  end
  res
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I found this method in one controller. It takes the hash and symbolize all
the keys. This functionality already implemented in the &lt;code&gt;active_support&lt;/code&gt; gem,
which is also enabled by default in rails. The method we are looking for -
&lt;a href=&#34;http://apidock.com/rails/Hash/symbolize_keys&#34;&gt;symbolize_keys&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Null migration, or What to do when there are too many migrations</title>
      <link>http://homeonrails.com/2012/11/null-migration-or-what-to-do-when-there-are-too-many-migrations/</link>
      <pubDate>Sun, 18 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>http://homeonrails.com/2012/11/null-migration-or-what-to-do-when-there-are-too-many-migrations/</guid>
      <description>&lt;p&gt;Migrations are probably one of the most killer features of ActiveRecord.
They allow you to design the architecture of the database along with the
growth of your project. If you change your data model (&lt;a href=&#34;http://martinfowler.com/eaaCatalog/domainModel.html&#34;&gt;Domain Model&lt;/a&gt;),
you reflect that change in code and write a migration (or several migrations),
which will make the necessary actions on your database schema. This may be
creating a new table, deleting a column or adding an unique index.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UPD (2015-02-15)&lt;/strong&gt;: recently I have discovered a gem called
&lt;a href=&#34;https://github.com/jalkoby/squasher&#34;&gt;squasher&lt;/a&gt;, which, I presume, does exactly
what this article describes, so check it before continuing reading.&lt;/p&gt;

&lt;p&gt;There are many benefits of using migrations, which you should definitely know
about. For example, independency from a particular database or the ability to
easily switch between different states of the database using the rake commands
&lt;code&gt;db:migrate&lt;/code&gt; and &lt;code&gt;db:rollback&lt;/code&gt;. More detailed information about them you could
find in the &lt;a href=&#34;http://guides.rubyonrails.org/migrations.html&#34;&gt;RailsGuides Migrations&lt;/a&gt; article.&lt;/p&gt;

&lt;h2 id=&#34;the-problem&#34;&gt;The problem&lt;/h2&gt;

&lt;p&gt;Sooner or later, especially in the long-running projects, &lt;strong&gt;the number of
migrations exceeds any acceptable norms&lt;/strong&gt;. When they are 50, it is perfectly
acceptable. But in really big projects, their number can be up to 500 or even more.&lt;/p&gt;

&lt;h2 id=&#34;what-can-we-do&#34;&gt;What can we do?&lt;/h2&gt;

&lt;p&gt;Create a &lt;strong&gt;null migration&lt;/strong&gt; (or initial migration) - migration, which contains
all previous migrations, i.e. the current state of the database schema
(&lt;code&gt;db/schema.rb&lt;/code&gt; or &lt;code&gt;db/sctructure.sql&lt;/code&gt;, depending on the format). Thus,
we get &lt;strong&gt;one migration instead of several hundred&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Pros:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;only one migration&lt;/li&gt;
&lt;li&gt;increased the speed and, consequently, reduced the time for running migrations&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cons:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;large size of the null migration&lt;/li&gt;
&lt;li&gt;all migrations merged into one, so we cannot switch between them any more&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let me remind you that the format of the database schema is defined in
&lt;code&gt;config/application.rb&lt;/code&gt; file using &lt;code&gt;config.active_record.schema_format&lt;/code&gt; parameter.
Possible values ​​are &lt;code&gt;:ruby&lt;/code&gt; ​​or &lt;code&gt;:sql&lt;/code&gt;. The default is &lt;code&gt;:ruby&lt;/code&gt;. The main difference
between them is that the second one goes with support for the functions specific
to a particular database (e.g., PostgreSQL sequences).&lt;/p&gt;

&lt;p&gt;Next, I will show how you can create a null migration.&lt;/p&gt;

&lt;h2 id=&#34;creating-a-null-migration-schema-format-ruby&#34;&gt;Creating a null migration (schema format - &lt;code&gt;:ruby&lt;/code&gt;)&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Dump your schema&lt;/li&gt;
&lt;li&gt;Create a migration&lt;/li&gt;
&lt;li&gt;Change migration timestamp&lt;/li&gt;
&lt;li&gt;Remove previous migrations&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;1-dump-your-schema&#34;&gt;1. Dump your schema&lt;/h3&gt;

&lt;p&gt;In most cases, you should already have a file &lt;code&gt;db/schema.rb&lt;/code&gt;. If not, use the following rake task:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; rake db:schema:dump
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It should do the job.&lt;/p&gt;

&lt;h3 id=&#34;2-create-a-migration&#34;&gt;2. Create a migration&lt;/h3&gt;

&lt;p&gt;Create a new migration named &lt;code&gt;NullMigration&lt;/code&gt; using Rails generator:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; rails g migration NullMigration
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Open the newly created migration. It should look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class NullMigration &amp;lt; ActiveRecord::Migration
  def up
  end

  def down
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now copy the contents of the &lt;code&gt;ActiveRecord::Schema.define&lt;/code&gt; block from a file &lt;code&gt;db/schema.rb&lt;/code&gt; into the method &lt;code&gt;up&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It remains to take care of the method &lt;code&gt;down&lt;/code&gt;, which is responsible for
rolling back our migration. Sure, we can go through all migrations and
copy the content of all &lt;code&gt;down&lt;/code&gt; methods, but it is too expensive. Instead,
let&amp;rsquo;s make our first migration irreversible, especially, there is no much
sense in rolling back to an empty database (we can always delete and create the required
database using the rake command &lt;code&gt;db:drop db:create&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;As a result, the migration should look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class NullMigration &amp;lt; ActiveRecord::Migration
  def up
    create_table &amp;quot;table&amp;quot;, :force =&amp;gt; true do |t|
    ...
  end

  def down
    raise ActiveRecord::IrreversibleMigration
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-change-migration-timestamp&#34;&gt;3. Change migration timestamp&lt;/h3&gt;

&lt;p&gt;Now, if you&amp;rsquo;d try to run a migration, you will get an error, because we already
have all the structures (tables, indexes) in our database. ActiveRecord checks
migration state (whether it was executed or not) by looking into
&lt;code&gt;schema_migrations&lt;/code&gt; table. This table basically holds the timestamps of
all executed migrations.&lt;/p&gt;

&lt;p&gt;So, if we do not want ActiveRecord to run our null migration, we either
need to manually insert its timestamp or change it (timestamp) to the last
executed migration timestamp, which is much easier to do.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s do this.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Find the file with the last executed migration (migration before the null migration) and copy its timestamp&lt;/li&gt;
&lt;li&gt;Replace the null migration timestamp with it.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Alternatively, you can find the required timestamp inside the
&lt;code&gt;ActiveRecord::Schema.define(:version =&amp;gt; 20120925084251)&lt;/code&gt; block (or at the end of
&lt;code&gt;null_schema.sql&lt;/code&gt; in case of &lt;code&gt;:sql&lt;/code&gt; schema format)&lt;/p&gt;

&lt;p&gt;Example (using the command line):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; ls db/migrate

20120925084251_add_state_to_task_topics.rb
20121120080714_null_migration.rb

&amp;gt; mv 20121120080714_null_migration.rb 20120925084251_null_migration.rb
&amp;gt; ls db/migrate

20120925084251_add_state_to_task_topics.rb
20120925084251_null_migration.rb
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-remove-previous-migrations&#34;&gt;4. Remove previous migrations&lt;/h3&gt;

&lt;p&gt;Now you only have to remove the previous migrations. I think this you can do without my help :)&lt;/p&gt;

&lt;h2 id=&#34;creating-a-null-migration-schema-format-sql&#34;&gt;Creating a null migration (schema format - &lt;code&gt;:sql&lt;/code&gt;)&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Dump your schema&lt;/li&gt;
&lt;li&gt;Create a migration&lt;/li&gt;
&lt;li&gt;Change migration timestamp&lt;/li&gt;
&lt;li&gt;Remove previous migrations&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;1-dump-your-schema-1&#34;&gt;1. Dump your schema&lt;/h3&gt;

&lt;p&gt;This step is not much different from the above, with the exception of the
schema file - &lt;code&gt;db/structure.sql&lt;/code&gt; and rake command to dump the database:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; rake db:structure:dump
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Would like to note that, unlike the command &lt;code&gt;rake db:schema:dump&lt;/code&gt;, which uses
built-in ActiveRecord schema dumper, this command uses special tools
specific to a particular database (for example, pg_dump for PostgreSQL).&lt;/p&gt;

&lt;h3 id=&#34;2-create-a-migration-1&#34;&gt;2. Create a migration&lt;/h3&gt;

&lt;p&gt;Create a migration (see a similar step above). Next, copy the file
&lt;code&gt;db/structure.sql&lt;/code&gt; into folder &lt;code&gt;db/migrate&lt;/code&gt; and rename it to &lt;code&gt;null_schema.sql&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Our migration would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class NullMigration &amp;lt; ActiveRecord::Migration
  def up
    file_data = File.read(&#39;db/migrate/null_schema.sql&#39;)
    ActiveRecord::Base.connection.execute file_data
  end

  def down
    raise ActiveRecord::IrreversibleMigration
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-change-migration-timestamp-1&#34;&gt;3. Change migration timestamp&lt;/h3&gt;

&lt;h3 id=&#34;4-remove-previous-migrations-1&#34;&gt;4. Remove previous migrations&lt;/h3&gt;

&lt;h2 id=&#34;wrapping-up&#34;&gt;Wrapping Up&lt;/h2&gt;

&lt;p&gt;Creating a null migration - a convenient way to get rid of a large number
of migrations. Therefore, we become able to restart the database development
cycle, i.e. to start from scratch.&lt;/p&gt;

&lt;p&gt;I believe that null migration was invented a long time ago, but I could
not find anything on the internet on this subject, so decided to share with
you. If you have any questions or additions, be sure to leave them
in the comments to this article.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Thank you to Alexey Astafyev, Alexander Rozhnov and Igor Kuznetsov for reviewing this post.&lt;/em&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Don&#39;t do this at home on Rails #2</title>
      <link>http://homeonrails.com/2012/11/dont-do-this-at-home-on-rails-2/</link>
      <pubDate>Sat, 10 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>http://homeonrails.com/2012/11/dont-do-this-at-home-on-rails-2/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;Languages: Ruby&lt;/li&gt;
&lt;li&gt;Difficulty: &lt;span class=&#34;label label-success&#34;&gt;Easy&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;Now is the time to break down the next three examples of code that look
slightly chapped, and just beg to be retouched. Despite the apparent
complexity, by running a series of easy refactorings, we can significantly
improve the code: reduce the size, improve the readability and even
increase its speed. Who knows?&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Well, let&amp;rsquo;s start.&lt;/p&gt;

&lt;h3 id=&#34;1-prefer-time-current-over-time-zone-now-or-time-zone&#34;&gt;#1 - prefer Time.current over Time.zone.now or Time.zone&lt;/h3&gt;

&lt;p&gt;Very often I see a code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;if schedulled_at &amp;gt; Time.zone.now
  ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And there is nothing wrong with it :) Seriously. But what if we have not set
the time zone? Most likely we&amp;rsquo;ll get an error. Just recently I came across a
method that does this check for us.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://apidock.com/rails/Time/current/class&#34;&gt;Time.current&lt;/a&gt; - returns
&lt;code&gt;Time.zone.now&lt;/code&gt; if the &lt;code&gt;Time.zone&lt;/code&gt; or &lt;code&gt;config.time_zone&lt;/code&gt; set,
otherwise just returns &lt;code&gt;Time.now&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;if schedulled_at &amp;gt; Time.current
  ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-avoid-using-before-filter&#34;&gt;#2 - Avoid using &lt;code&gt;before_filter&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;before_filter&lt;/code&gt; is used inside controllers to execute any code before any action
will be executed. This allows us to avoid duplicating code. But, like any tool,
it can be used &amp;ldquo;in the wrong way&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class SubscribesController &amp;lt; ApplicationController
  before_filter :load_subscribe, only: [:show, :destroy]

  def index
    @subscribes = Subscribe.all
  end

  def show
  end

  def destroy
    @subscribe.destroy
    redirect_to :root
  end

  private

    def load_subscribe
      @subscribe = Subscribe.find_by_name(params[:id]) || raise(ActiveRecord::RecordNotFound)
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I do not mind eliminating duplication, especially when the private method below
does consist of 40 lines, for example. I just think, logic should be more explicit
here. Otherwise, to understand what makes a particular action, the programmer
must first look at all before filters, then look at the methods that are
called by these filters and only then he or she comes to the action itself. This makes
the application logic confusing and difficult to understand.&lt;/p&gt;

&lt;p&gt;Before filters are really helpful in some cases. For example, when we need to check
whether the user is authorized or log each request.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class SubscribesController &amp;lt; ApplicationController
  def index
    @subscribes = Subscribe.all
  end

  def show
    load_subscribe
  end

  def destroy
    load_subscribe
    @subscribe.destroy
    redirect_to :root
  end

  private

  def load_subscribe
    @subscribe = Subscribe.find_by_name!(params[:id])
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you look at each action it doesn&amp;rsquo;t seem like the instance variables appear
magically. As the capabilities of a controller increases in size it becomes more
difficult to see the &amp;ldquo;magic&amp;rdquo; of a before filter hidden somewhere in the app
and the explicitness of method calling becomes very helpful.&lt;/p&gt;

&lt;p&gt;Note that I added &lt;code&gt;!&lt;/code&gt; sign to the &lt;code&gt;find_by_name&lt;/code&gt; method, which now throws an exception if the
corresponding record is not found. Next, I would probably get rid of the private
method, since it consists only of one line.&lt;/p&gt;

&lt;h3 id=&#34;3-use-powerful-enumerable-methods-example-with-select&#34;&gt;#3 - Use powerful &lt;code&gt;Enumerable&lt;/code&gt; methods (example with &lt;code&gt;select&lt;/code&gt;)&lt;/h3&gt;

&lt;p&gt;Module &lt;a href=&#34;http://ruby-doc.org/core-1.9.3/Enumerable.html&#34;&gt;Enumerable&lt;/a&gt; provides a
variety of methods for manipulating, traversing and searching though a
collection. It is very hard to remember them all, but that is not necessary.
What is required of us, is to simplify code by maximum.&lt;/p&gt;

&lt;p&gt;Now I will show you two main sources that help me every day:
- &lt;a href=&#34;http://apidock.com/&#34;&gt;APIdock&lt;/a&gt;
- &lt;a href=&#34;http://ruby-doc.org/core-1.9.3/&#34;&gt;Ruby 1.9.3 Doc&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# before
@groups = Group.all.find_all { |g| g.admin?(current_user) }
@projects = Project.all.find_all { |p| p.admin?(current_user) }

# after
@groups = Group.select { |g| g.admin?(current_user) }
@projects = Project.select { |p| p.admin?(current_user) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, the code has not changed much.
But, using such a bricks, we can build really powerful self-documenting code.&lt;/p&gt;

&lt;p&gt;After all, this leads to a reducing of complexity, which makes the code
transparent and flexible. As a result, we can do refactor
it without any problems.&lt;/p&gt;

&lt;p&gt;And that&amp;rsquo;s all for today folks!&lt;/p&gt;

&lt;h2 id=&#34;follow-up&#34;&gt;Follow up&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://homeonrails.com/2013/01/dont-do-this-at-home-on-rails-3&#34;&gt;Don&amp;rsquo;t do this at home on Rails #3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>AssociationCountValidator</title>
      <link>http://homeonrails.com/2012/10/associationcountvalidator/</link>
      <pubDate>Wed, 10 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>http://homeonrails.com/2012/10/associationcountvalidator/</guid>
      <description>&lt;p&gt;As a result of my &lt;a href=&#34;http://homeonrails.com/2012/10/validating-nested-associations-in-rails&#34;&gt;previous blog post&lt;/a&gt;
about validating nested associations, I wrote custom validator for Rails 3.
It is intended to help you to validate records count in a given association.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# lib/association_count_validator.rb
class AssociationCountValidator &amp;lt; ActiveModel::Validations::LengthValidator
  MESSAGES = { :wrong_length =&amp;gt; :association_count_invalid,
               :too_short =&amp;gt; :association_count_greater_than_or_equal_to,
               :too_long =&amp;gt; :association_count_less_than_or_equal_to }.freeze

  def initialize(options)
    MESSAGES.each { |key, message| options[key] ||= message }
    super
  end

  def validate_each(record, attribute, value)
    existing_records = record.send(attribute).reject(&amp;amp;:marked_for_destruction?)
    super(record, attribute, existing_records)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Probably, you noticed that this is just a wrapper over the standard &lt;code&gt;LengthValidator&lt;/code&gt;.
This has a big advantage - all options, provided by the basic validator, are supported.
And it correctly handles the situation with marked for destruction records,
which was mentioned in the previous post.&lt;/p&gt;

&lt;p&gt;Usage:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Company &amp;lt; ActiveRecord::Base
  OFFICES_COUNT_MIN = 1

  attr_accessible :name, :offices_attributes

  validates :name, presence: true
  validates :offices, association_count: { minimum: OFFICES_COUNT_MIN }

  has_many :offices, inverse_of: :company

  accepts_nested_attributes_for :offices, allow_destroy: true
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Do not forget to add custom error messages to your localization files.&lt;/p&gt;

&lt;p&gt;Example for &lt;code&gt;en&lt;/code&gt; culture:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;en:
  errors:
    messages:
      association_count_less_than_or_equal_to:
        one: count must be less than 1
        other: count must be less than or equal to %{count}
      association_count_greater_than_or_equal_to:
        one: count must be greater than 1
        other: count must be greater than or equal to %{count}
      association_count_invalid:
        one: count is invalid (must be equal to 1)
        other: count is invalid (must be equal to %{count})
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Validating nested associations in Rails</title>
      <link>http://homeonrails.com/2012/10/validating-nested-associations-in-rails/</link>
      <pubDate>Mon, 08 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>http://homeonrails.com/2012/10/validating-nested-associations-in-rails/</guid>
      <description>&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;Rails provide a wide range of options for creating rich forms for your models.
This can be a simple form for one object, or the form for many related objects.
Usually it is a parent-children relations. If you are not familiar with such terms
as &lt;a href=&#34;http://api.rubyonrails.org/classes/ActionView/Helpers/FormHelper.html#M001605&#34;&gt;form_for&lt;/a&gt;
or &lt;a href=&#34;http://api.rubyonrails.org/classes/ActiveRecord/NestedAttributes/ClassMethods.html#M002132&#34;&gt;accepts_nested_attributes_for&lt;/a&gt;,
I strongly recommend taking a look at this article &lt;a href=&#34;http://rubysource.com/complex-rails-forms-with-nested-attributes/&#34;&gt;Complex Rails Forms with Nested Attributes&lt;/a&gt;,
written by &lt;a href=&#34;http://xaviershay.com/&#34;&gt;Xavier Shay&lt;/a&gt;, which will show your how you can create complex forms with Rails.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;an-example&#34;&gt;An example&lt;/h2&gt;

&lt;p&gt;Suppose, we have a model called &lt;code&gt;Company&lt;/code&gt;. And the company may have several offices.
Lets define these two models.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Company &amp;lt; ActiveRecord::Base
  attr_accessible :name, :offices_attributes
  validates :name, presence: true
  has_many :offices
  accepts_nested_attributes_for :offices, allow_destroy: true
end

class Company::Office &amp;lt; ActiveRecord::Base
  attr_accessible :company_id, :name
  validates :name, presence: true
  belongs_to :company
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both company and office have names. The company could have zero or more offices.&lt;/p&gt;

&lt;p&gt;By including &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt; it becomes possible to access
offices attributes inside our &lt;code&gt;Company&lt;/code&gt; model.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; c = Company.create(name: &#39;Mars LLC&#39;)
&amp;gt;   =&amp;gt; #&amp;lt;Company id: 1, name: &amp;quot;Mars LLC&amp;quot;, created_at: &amp;quot;2012-10-08 19:16:44&amp;quot;, updated_at: &amp;quot;2012-10-08 19:16:44&amp;quot;&amp;gt;

# add two new offices
&amp;gt; c.offices_attributes = [{ name: &#39;North America&#39; }, { name: &#39;Europe&#39; }]
&amp;gt;   =&amp;gt; [{:name=&amp;gt;&amp;quot;North America&amp;quot;}, {:name=&amp;gt;&amp;quot;Europe&amp;quot;}]
&amp;gt; c.save
&amp;gt; c.offices
&amp;gt;   =&amp;gt; [#&amp;lt;Company::Office id: 1, company_id: 1, name: &amp;quot;North America&amp;quot;, created_at: &amp;quot;2012-10-08 19:21:54&amp;quot;, updated_at: &amp;quot;2012-10-08 19:21:54&amp;quot;&amp;gt;, #&amp;lt;Company::Office id: 2, company_id: 1, name: &amp;quot;Europe&amp;quot;, created_at: &amp;quot;2012-10-08 19:21:54&amp;quot;, updated_at: &amp;quot;2012-10-08 19:21:54&amp;quot;&amp;gt;]

# edit office in North America
&amp;gt; c.offices_attributes = [{ id: 1, name: &amp;quot;North America (it&#39;s cold out there)&amp;quot; }]
&amp;gt;   =&amp;gt; [{:id=&amp;gt;1, :name=&amp;gt;&amp;quot;North America (it&#39;s cold out there)&amp;quot;}]
&amp;gt; c.save
&amp;gt; c.offices
&amp;gt;   =&amp;gt; [#&amp;lt;Company::Office id: 1, company_id: 1, name: &amp;quot;North America (it&#39;s cold out there)&amp;quot;, created_at: &amp;quot;2012-10-08 19:21:54&amp;quot;, updated_at: &amp;quot;2012-10-08 19:25:18&amp;quot;&amp;gt;, #&amp;lt;Company::Office id: 2, company_id: 1, name: &amp;quot;Europe&amp;quot;, created_at: &amp;quot;2012-10-08 19:21:54&amp;quot;, updated_at: &amp;quot;2012-10-08 19:21:54&amp;quot;&amp;gt;]

# delete an office in Europe
&amp;gt; c.offices_attributes = [{ id: 2, _destroy: &#39;1&#39; }]
&amp;gt;   =&amp;gt; [{:id=&amp;gt;2, :_destroy=&amp;gt;&amp;quot;1&amp;quot;}]
&amp;gt; c.save
&amp;gt; c.offices
&amp;gt;   =&amp;gt; [#&amp;lt;Company::Office id: 1, company_id: 1, name: &amp;quot;North America (it&#39;s cold out there)&amp;quot;, created_at: &amp;quot;2012-10-08 19:21:54&amp;quot;, updated_at: &amp;quot;2012-10-08 19:25:18&amp;quot;&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two basic options, that you should know when dealing with &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;allow_destroy&lt;/code&gt; - allows to destroy objects (&lt;code&gt;false&lt;/code&gt; by default)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reject_if&lt;/code&gt; - rejects the records, based on the given  &lt;code&gt;Proc&lt;/code&gt; or
a &lt;code&gt;Symbol&lt;/code&gt; pointing to a method. This one is simular to the &lt;code&gt;Enumerable::reject&lt;/code&gt; method (&lt;a href=&#34;http://www.ruby-doc.org/core-1.9.3/Enumerable.html#method-i-reject&#34;&gt;Doc&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Take a look at the other supported options on &lt;a href=&#34;http://apidock.com/rails/ActiveRecord/NestedAttributes/ClassMethods/accepts_nested_attributes_for&#34;&gt;apidock.com&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;validating-nested-attributes&#34;&gt;Validating nested attributes&lt;/h3&gt;

&lt;p&gt;Except the basic validation, you can use &lt;code&gt;reject_if&lt;/code&gt; option to validate a nested object.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Company &amp;lt; ActiveRecord::Base
  attr_accessible :name, :offices_attributes
  validates :name, presence: true
  has_many :offices
  accepts_nested_attributes_for :offices, allow_destroy: true, reject_if: :office_name_invalid

  private

    def office_name_invalid(attributes)
      # office name shouldn&#39;t start with underscore
      attributes[&#39;name&#39;] =~ /\A_/
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The method should return either true (rejects the record) or false.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; c.offices_attributes = [{ id: 1, name: &#39;_North America&#39;}]
&amp;gt;   =&amp;gt; [{:id=&amp;gt;1, :name=&amp;gt;&amp;quot;_North America&amp;quot;}]
&amp;gt; c.save
&amp;gt; c.offices # no changes
&amp;gt;   =&amp;gt; [#&amp;lt;Company::Office id: 1, company_id: 1, name: &amp;quot;North America&amp;quot;, created_at: &amp;quot;2012-10-08 19:21:54&amp;quot;, updated_at: &amp;quot;2012-10-08 19:46:22&amp;quot;&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could use predefined &lt;code&gt;:all_blank&lt;/code&gt; symbol.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; c.offices_attributes = [{ name: &#39;&#39;}]
&amp;gt;   =&amp;gt; [{:name=&amp;gt;&amp;quot;&amp;quot;}]
&amp;gt; c.save
&amp;gt; c.offices # no changes
&amp;gt;   =&amp;gt; [#&amp;lt;Company::Office id: 1, company_id: 1, name: &amp;quot;North America&amp;quot;, created_at: &amp;quot;2012-10-08 19:21:54&amp;quot;, updated_at: &amp;quot;2012-10-08 19:46:22&amp;quot;&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Passing &lt;code&gt;:all_blank&lt;/code&gt; instead of a Proc will create a proc that will reject a record where all the attributes are blank excluding any value for &lt;code&gt;_destroy&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;validating-count-of-the-nested-attributes&#34;&gt;Validating count of the nested attributes&lt;/h3&gt;

&lt;p&gt;Lets add more complexity to our company model and say for example: it &lt;strong&gt;must have at least one
office&lt;/strong&gt; (we usually called it the main office).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Company &amp;lt; ActiveRecord::Base
  OFFICES_COUNT_MIN = 1

  attr_accessible :name, :offices_attributes
  validates :name, presence: true
  validate do
    check_offices_number
  end
  has_many :offices
  accepts_nested_attributes_for :offices, allow_destroy: true

  private

    def offices_count_valid?
      offices.count &amp;gt;= OFFICES_COUNT_MIN
    end

    def check_offices_number
      unless offices_count_valid?
        errors.add(:base, :offices_too_short, :count =&amp;gt; OFFICES_COUNT_MIN)
      end
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem here is that accepts_nested_attributes_for call destroy for child
objects &lt;strong&gt;AFTER&lt;/strong&gt; validation of the parent object. So the user is able to delete
an office. Of course, later, when the user will try to edit a company,
he/she will get an error - &amp;ldquo;Company should have at least one office.&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://homeonrails.com/images/posts/2012-10-08-validating-nested-associations-in-rails/flowchart.png&#34; alt=&#34;Flowchart of the validation process&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; c.offices_attributes = [{ id: 1, _destroy: &#39;1&#39; }]
&amp;gt;   =&amp;gt; [{:id=&amp;gt;1, :_destroy=&amp;gt;&amp;quot;1&amp;quot;}]
&amp;gt; c.save
&amp;gt; c.offices
&amp;gt;   =&amp;gt; []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You could try to use standard &lt;code&gt;length&lt;/code&gt; validator
(e.g. &lt;code&gt;validates :offices, length: { minimum: OFFICES_COUNT_MIN }&lt;/code&gt;), and it actually works,
but again, it does not take into account the fact that some of the records may
be marked for destruction.&lt;/p&gt;

&lt;p&gt;The things are getting a little tricky here.
To sort out the problem, we need to understand what &lt;code&gt;offices_attributes=&lt;/code&gt; method does.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# accepts_nested_attributes_for generates for us this method
def offices_attributes=(attributes)
  # @note the name of the method to call may vary depending on the type of association
  # @see https://github.com/rails/rails/blob/master/activerecord/lib/active_record/nested_attributes.rb#L285
  assign_nested_attributes_for_collection_association(:offices, attributes, mass_assignment_options)
end

def assign_nested_attributes_for_collection_association
  ...
  if !call_reject_if(association_name, attributes) # if the record passed
    # update a record with the attributes or marks it for destruction
    assign_to_or_mark_for_destruction(existing_record, attributes, options[:allow_destroy], assignment_opts)
  end
  ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see from the code above, our method marks offices records (with &lt;code&gt;_destroy&lt;/code&gt; attribute) for destruction.
When the company validates offices count, the offices relation includes &lt;strong&gt;all&lt;/strong&gt; the records.
So, all we need to do is to select only those records not marked for destruction.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Company &amp;lt; ActiveRecord::Base
  ...

  private

    def offices_count_valid?
      offices.reject(&amp;amp;:marked_for_destruction?).count &amp;gt;= OFFICES_COUNT_MIN
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we&amp;rsquo;ve got the actual number of the company&amp;rsquo;s offices. Therefore, we will get an error while trying to delete the last office in North America:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; c.offices_attributes = [{ id: 1, _destroy: &#39;1&#39; }]
&amp;gt;   =&amp;gt; [{:id=&amp;gt;1, :_destroy=&amp;gt;&amp;quot;1&amp;quot;}]
&amp;gt; c.save
&amp;gt; c.errors
&amp;gt;   =&amp;gt; #&amp;lt;ActiveModel::Errors:0x000000038fc840 @base=#&amp;lt;Company id: 1, name: &amp;quot;Mars LLC&amp;quot;, created_at: &amp;quot;2012-10-08 19:16:44&amp;quot;, updated_at: &amp;quot;2012-10-08 19:16:44&amp;quot;&amp;gt;, @messages={:base=&amp;gt;[&amp;quot;Company should have at least one office.&amp;quot;]}&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hopefully, in Rails 3 we are now able to write our own custom validators, so I&amp;rsquo;ve added &lt;a href=&#34;http://homeonrails.com/2012/10/associationcountvalidator&#34;&gt;one more for this case&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you know a better solution, don&amp;rsquo;t hesitate to &lt;a href=&#34;http://homeonrails.com/about.html&#34;&gt;contact me&lt;/a&gt; or simply leave a comment below.&lt;/p&gt;

&lt;h3 id=&#34;validating-presence-of-the-parent-object&#34;&gt;Validating presence of the parent object&lt;/h3&gt;

&lt;p&gt;The last thing I wanna share with you is how you can add &lt;code&gt;presence&lt;/code&gt; validator
to the parent association inside the nested model.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Company::Office &amp;lt; ActiveRecord::Base
  attr_accessible :company_id, :name

  validates :name, presence: true
  # add validator to company
  validates :company, presence: true

  belongs_to :company
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We want to be sure that the office always have a corresponding company. But this fails on creating a company.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; c = Company.create(name: &#39;Adidas America Inc&#39;, offices_attributes: [{ name: &#39;LS&#39; }])
&amp;gt;   =&amp;gt; #&amp;lt;Company id: nil, name: &amp;quot;Adidas America Inc&amp;quot;, created_at: nil, updated_at: nil&amp;gt;
&amp;gt; c.errors
&amp;gt;   =&amp;gt; #&amp;lt;ActiveModel::Errors:0x000000036387a8 @base=#&amp;lt;Company id: nil, name: &amp;quot;Adidas America Inc&amp;quot;, created_at: nil, updated_at: nil&amp;gt;, @messages={:&amp;quot;offices.company&amp;quot;=&amp;gt;[&amp;quot;can&#39;t be blank&amp;quot;]}&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The solution here is to use &lt;code&gt;inverse_of&lt;/code&gt; option. See the options section
in &lt;code&gt;belongs_to&lt;/code&gt;, &lt;code&gt;has_one&lt;/code&gt; or &lt;code&gt;has_many&lt;/code&gt; &lt;a href=&#34;http://apidock.com/rails/ActiveRecord/Associations/ClassMethods/belongs_to&#34;&gt;documentation&lt;/a&gt;.
Note: it does not work in combination with the &lt;code&gt;polymorphic&lt;/code&gt; option.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Company &amp;lt; ActiveRecord::Base
  ...
  has_many :offices, inverse_of: :company
  ...
end

class Company::Office &amp;lt; ActiveRecord::Base
  ...
  belongs_to :company, inverse_of: :offices
  ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we are able to create a company instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; c = Company.create(name: &#39;Adidas America Inc&#39;, offices_attributes: [{ name: &#39;LS&#39; }])
&amp;gt;   =&amp;gt; #&amp;lt;Company id: 2, name: &amp;quot;Adidas America Inc&amp;quot;, created_at: &amp;quot;2012-10-09 07:36:07&amp;quot;, updated_at: &amp;quot;2012-10-09 07:36:07&amp;quot;&amp;gt;
&amp;gt; c.offices
&amp;gt;   =&amp;gt; #&amp;lt;Company::Office id: 6, company_id: 2, name: &amp;quot;LS&amp;quot;, created_at: &amp;quot;2012-10-09 07:36:07&amp;quot;, updated_at: &amp;quot;2012-10-09 07:36:07&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Don&#39;t do this at home on Rails #1</title>
      <link>http://homeonrails.com/2012/09/dont-do-this-at-home-on-rails-1/</link>
      <pubDate>Sun, 23 Sep 2012 00:00:00 +0000</pubDate>
      
      <guid>http://homeonrails.com/2012/09/dont-do-this-at-home-on-rails-1/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;Languages: Ruby&lt;/li&gt;
&lt;li&gt;Difficulty: &lt;span class=&#34;label label-success&#34;&gt;Easy&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;These series of articles will be dedicated to every day code, that I am working on.
This could be the parts of my own projects or some ruby gems. Together, we will try to improve quality and readability of it.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;examples&#34;&gt;Examples&lt;/h2&gt;

&lt;h3 id=&#34;1-avoid-duplication&#34;&gt;#1 - avoid duplication&lt;/h3&gt;

&lt;p&gt;The first example is a scope, that fetches the records within a given range.
If the &lt;code&gt;date&lt;/code&gt; param passed to this block responds to the &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; methods,
these are considered as start and end dates. Otherwise, it selects records for that date plus 1 day.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;scope :at_date, lambda { |date|
  if date.respond_to?(:last) &amp;amp;&amp;amp; date.respond_to?(:first)
    where(&amp;quot;created_at &amp;gt;= ? AND created_at &amp;lt;= ?&amp;quot;, date.first, date.last)
  else
    where(&amp;quot;created_at &amp;gt;= ? AND created_at &amp;lt;= ?&amp;quot;, date, date + 1.day)
  end
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What could you say about this code? Is it well written? This code has many flaws.
The first thing that caches the eye is duplicated &lt;code&gt;where&lt;/code&gt; condition.
Just imagine, each time you want to change the query, you will need to update these 2 lines.
Lets fix this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;scope :at_date, lambda { |date|
  if date.respond_to?(:last) &amp;amp;&amp;amp; date.respond_to?(:first)
    date_start = date.first
    date_end = date.last
  else
    date_start = date
    date_end = date_start + 1.day
  end

  where(&amp;quot;created_at &amp;gt;= ? AND created_at &amp;lt;= ?&amp;quot;, date_start, date_end)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Good, but that&amp;rsquo;s not all.&lt;/p&gt;

&lt;p&gt;It seems to me very confusing, that &lt;code&gt;date&lt;/code&gt; param could be
either &lt;code&gt;Array&lt;/code&gt; or &lt;code&gt;DateTime&lt;/code&gt;. Strictly speaking, it could be anything;
e.g &lt;code&gt;String&lt;/code&gt; - it&amp;rsquo;s also responds to &lt;code&gt;first/last&lt;/code&gt; methods, so as a result
we will get this query &lt;code&gt;created_at &amp;gt;= 2 and created_at &amp;lt;= 3&lt;/code&gt; for date = &amp;lsquo;2012-09-23&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;But wait, ActiveRecord&amp;rsquo;s query interface also supports ranges as an arguments,
so we could write something like this: &lt;code&gt;where(created_at: date.first..date.last)&lt;/code&gt;,
which will generate a query &lt;code&gt;created_at BETWEEN &amp;lt;date.first&amp;gt; AND &amp;lt;date.last&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;scope :at_date, lambda { |range|
  where(created_at: range)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-try-to-search-for-existing-method-first&#34;&gt;#2 - try to search for existing method first&lt;/h3&gt;

&lt;p&gt;The second slice of code selects the channels, locked by the current user and
free channels.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;cu = current_user
locked = channels.select{ |ch| ch.is_locked_by?(cu) }
free   = channels.select{ |ch| !ch.is_locked_by?(cu) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Did you notice the reverse condition? Every time I see the code,
who looks like this, I thought, it should be already a method for this in ruby.
In fact, ruby and rails has a greater collection of methods. Take a look at &lt;code&gt;ActiveSupport&lt;/code&gt;
methods &lt;a href=&#34;http://apidock.com/rails/ActiveSupport&#34;&gt;http://apidock.com/rails/ActiveSupport&lt;/a&gt;. But what about our case? After a few minutes
of searching, I&amp;rsquo;ve found &lt;code&gt;partition&lt;/code&gt; method (&lt;a href=&#34;http://apidock.com/ruby/Enumerable/partition&#34;&gt;Doc&lt;/a&gt;),
which does exactly just we want to - splits collection into two arrays by a given condition.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;locked, unlocked = channels.partition { |ch| ch.is_locked_by?(current_user) }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-think-about-what-you-are-writing-right-now&#34;&gt;#3 - think about what you are writing right now&lt;/h3&gt;

&lt;p&gt;The third method is a simple method inside some model.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def has_description?
  !self.description.blank?
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I know what you are thinking right now - it&amp;rsquo;s not my :)&lt;/p&gt;

&lt;p&gt;There are two drawbacks in the code above. The one significant is that there is already a
method for this in &lt;code&gt;ActiveRecord&lt;/code&gt;. Rails creates a method called &lt;code&gt;&amp;quot;{attribute}?&amp;quot;&lt;/code&gt;,
which checks whether a field is defined or not. So we could remove &lt;code&gt;has_description?&lt;/code&gt;
method with &lt;code&gt;description?&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note: you don&amp;rsquo;t have to use &lt;code&gt;self&lt;/code&gt; inside the model methods, because we already in the context of an object.&lt;/p&gt;

&lt;p&gt;And that&amp;rsquo;s all for today. Hope you&amp;rsquo;ve caught something for you!&lt;/p&gt;

&lt;h2 id=&#34;follow-up&#34;&gt;Follow up&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://homeonrails.com/2012/11/dont-do-this-at-home-on-rails-2&#34;&gt;Don&amp;rsquo;t do this at home on Rails #2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>