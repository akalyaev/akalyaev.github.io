<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Profiling on Home on Rails</title>
    <link>http://homeonrails.com/tags/profiling/index.xml</link>
    <description>Recent content in Profiling on Home on Rails</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>All rights reserved - 2017</copyright>
    <atom:link href="http://homeonrails.com/tags/profiling/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Не верь своему тимлиду</title>
      <link>http://homeonrails.com/2015/10/dont-trust-your-devlead/</link>
      <pubDate>Thu, 22 Oct 2015 10:16:35 +0000</pubDate>
      
      <guid>http://homeonrails.com/2015/10/dont-trust-your-devlead/</guid>
      <description>&lt;p&gt;&amp;ldquo;Не верь своему тимлиду&amp;rdquo; или когда не стоит слепо верить словам вашего тимлида.&lt;/p&gt;

&lt;div style=&#34;align:center&#34;&gt;
  &lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2015-10-22-dont-trust-your-devlead/dog.png&#34; alt=&#34;&#34; width=&#34;100%&#34; title=&#34;&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Большинство моих читателей находится в подчинении у тимлида или VP of
Engineering, словом у человека, умудренного опытом или, по крайней мере,
знающего побольше своих подчиненных. И это нормально. И ты доверяешь опыту
данного человека, но бывают случаи, когда стоит все же проверить прав он или
нет.&lt;/p&gt;

&lt;p&gt;Так вот, приключился давеча со мной забавный случай. В одном из пулл-реквестов
VP of Engineering мне написал: &amp;ldquo;Тут можно сильно разогнать, используя в
качестве аккумулятора dict и обновляя значения через dict:update.&amp;ldquo;.&lt;/p&gt;

&lt;p&gt;А вот и код, о котором идет речь:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;% for every Item in Items, коих около 5000
NewAcc = case gb_sets:is_member(RangeStart, RangeStarts) of
  false -&amp;gt;
    case lists:keyfind(norange, 1, Acc) of
      {norange, List} -&amp;gt; [{norange, [Item|List]}|lists:keydelete(norange, 1, Acc)];
      false -&amp;gt; [{norange, [Item]}|Acc]
    end;
  true -&amp;gt;
    case lists:keyfind(RangeStart, 1, Acc) of
      {RangeStart, List} -&amp;gt; [{RangeStart, [Item|List]}|lists:keydelete(RangeStart, 1, Acc)];
      false -&amp;gt; [{RangeStart, [Item]}|Acc]
    end
end,
...
% позже возвращаем результирующий список
NewAcc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Обратите внимание, что элементы range хранятся в списках и все операции (за
исключением поиска в сбалансированном дереве) производятся над списками.&lt;/p&gt;

&lt;p&gt;Я решил проверить, действительно ли использование dict способно повысить
производительность данного кода (т.е. сократить время выполнения). Для начала
замерил скорость работы со списками:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Range: 398 - 7667 mics
Median: 1798 mics
Average: 1846 mics
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Потом попробовал &lt;code&gt;dict:append_list&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;% for every Item in Items, коих около 5000
NewAcc = case gb_sets:is_member(RangeStart, RangeStarts) of
  false -&amp;gt;
    case dict:is_key(norange, Acc) of
      false -&amp;gt; dict:append(norange, Item, Acc);
      true -&amp;gt; dict:append_list(norange, [Item], Acc)
    end;
  true -&amp;gt;
    case dict:is_key(RangeStart, Acc) of
      false -&amp;gt; dict:append(RangeStart, Item, Acc);
      true -&amp;gt; dict:append_list(RangeStart, [Item], Acc)
    end
end,
...
% позже возвращаем результирующий список
dict:to_list(NewAcc)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Range: 61466 - 94095 mics
Median: 67062 mics
Average: 68343 mics
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Он оказался значительно медленнее (из-за того, что списки склеиваются с помощью &lt;code&gt;++&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Затем попробовал &lt;code&gt;dict:update&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;% for every Item in Items, коих около 5000
Key = case gb_sets:is_member(RangeStart, RangeStarts) of
  false -&amp;gt; norange;
  true -&amp;gt; RangeStart
end,
NewAcc = dict:update(Key, fun(List) -&amp;gt; [Item|List] end, [Item], Acc),
...
% позже возвращаем результирующий список
dict:to_list(NewAcc)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Range: 4044 - 11357 mics
Median: 4672 mics
Average: 4963 mics
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Кода меньше в разы, но по скорости уступает, а на данном участке нам важна была
именно скорость.&lt;/p&gt;

&lt;p&gt;&lt;div style=&#34;align:center&#34;&gt;
  &lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2015-10-22-dont-trust-your-devlead/avgs.png&#34; alt=&#34;&#34; width=&#34;100%&#34; title=&#34;&#34;/&gt;
&lt;/div&gt;
(&lt;em&gt;создал диаграмму с помощью R&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Конкретные цифры не так важны, ибо они зависят от множества факторов, включая
размер входящего списка Items, количества RangeStart&amp;rsquo;ов, машинку, на которой
это все запускается, версию Erlang и т.п.&lt;/p&gt;

&lt;p&gt;Что важно, так это то, что профессионал своего дела должен уметь распознать
таковые моменты, когда стоит проверить указания или советы вашего тимлида. Я не
думаю, что есть конкретные условия или признаки, которые подскажут вам
необходимость проверки. Скорее знание структур данных используемого вами языка
и механизма работы VM и ОС помогут вам научиться распознавать такие случаи. Так
что читайте книги и помните правило - &amp;ldquo;доверяй, но проверяй&amp;rdquo;.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>