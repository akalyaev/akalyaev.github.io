<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ruby on Home on Rails</title>
    <link>http://homeonrails.com/tags/ruby/index.xml</link>
    <description>Recent content in Ruby on Home on Rails</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>All rights reserved - 2017</copyright>
    <atom:link href="http://homeonrails.com/tags/ruby/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>From Ruby To Erlang. Beginner&#39;s mistakes</title>
      <link>http://homeonrails.com/2015/08/from-ruby-to-erlang/</link>
      <pubDate>Mon, 03 Aug 2015 15:09:10 +0000</pubDate>
      
      <guid>http://homeonrails.com/2015/08/from-ruby-to-erlang/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve  been programming full-time using Erlang for a while already (about eight
months or so). Before Erlang, I was doing some hardcore Ruby. Obviously, these
are very different languages: OOP vs functional, mutable vs immutable and so
on. Also, there are things you won&amp;rsquo;t find in Ruby (the opposite is also true).&lt;/p&gt;

&lt;p&gt;In this post I want to show you the mistakes that I&amp;rsquo;ve made and the lessons
that I&amp;rsquo;ve learned during the transition.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-list-comprehensions&#34;&gt;1. List Comprehensions&lt;/h2&gt;

&lt;p&gt;There is no such thing as List Comprehension in Ruby (but you could write
&lt;a href=&#34;http://blog.tarkalabs.com/2015/04/21/list-comprehension-in-ruby/&#34;&gt;something similar&lt;/a&gt;), so when I was using it in Erlang, I didn&amp;rsquo;t fully
understand how it works. Let me show you.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;[X || X &amp;lt;- [1,2,3,4,5,6], X &amp;gt; 3].
=&amp;gt; [4,5,6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are 3 main components here:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;X &amp;lt;- [1,2,3,4,5,6]&lt;/code&gt; - &lt;strong&gt;generator&lt;/strong&gt; - usually some set of elements;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;X &amp;gt; 3&lt;/code&gt; - &lt;strong&gt;filter&lt;/strong&gt; - conditions, that we impose on these elements;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;X&lt;/code&gt; - &lt;strong&gt;list&lt;/strong&gt; - expression, which gives us the resulting element.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2015-08-03-from-ruby-to-erlang/listc1.png&#34; alt=&#34;&#34;/ width=&#34;100%&#34; title=&#34;&#34;&gt;&lt;/p&gt;

&lt;p&gt;I thought that, the way it works is &amp;ldquo;one by one&amp;rdquo;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;element is taken from generator;&lt;/li&gt;
&lt;li&gt;if it passes all the filters, the expression on the left gets executed;
otherwise, goto (1).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As it turned out, I was wrong. I&amp;rsquo;ve noticed it, when I wrote a for loop using
list comprehension, and, later on, one of the filters fell.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;[save(Rec, Db) || Rec &amp;lt;- Records, is_dirty(Rec), can_be_saved(Rec)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;this is not the production code&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;What do you think will happen if &lt;code&gt;can_be_saved&lt;/code&gt; throw an error for the
third record? &lt;strong&gt;Correct answer&lt;/strong&gt;: non of the records will be saved.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2015-08-03-from-ruby-to-erlang/listc2.png&#34; alt=&#34;&#34;/ width=&#34;100%&#34; title=&#34;&#34;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2015-08-03-from-ruby-to-erlang/listc3.png&#34; alt=&#34;&#34;/ width=&#34;100%&#34; title=&#34;&#34;&gt;&lt;/p&gt;

&lt;p&gt;The way it works is &amp;ldquo;one by one || one by one&amp;rdquo;: firstly, Erlang generates and
filters initial list. After that, it executes expression on the left side for
each item resulting in a new list.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lesson #1. List Comprehension should not be used when you need a for loop. Instead, use recursion.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;save_records([], _) -&amp;gt; ok;
save_records([Rec|Rest], Db) -&amp;gt;
    try
        case is_dirty(Rec) of
            false -&amp;gt; throw({filtered, io_lib:format(&amp;quot;~p not dirty&amp;quot;, [Rec])});
            true -&amp;gt; ok
        end,
        case can_be_saved(Rec) of
            false -&amp;gt; throw({filtered, io_lib:format(&amp;quot;~p cannot be saved&amp;quot;, [Rec])});
            true -&amp;gt; ok
        end
    of _ -&amp;gt;
        save(Rec, Db)
    catch
        throw:{filtered, Reason} -&amp;gt; lager:debug(Reason)
    end,
    save_records(Rest, Db).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This way, if &lt;code&gt;can_be_saved&lt;/code&gt; does throw an error, at least some of the records
will be saved.&lt;/p&gt;

&lt;h2 id=&#34;2-lager&#34;&gt;2. Lager&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/basho/lager&#34;&gt;lager&lt;/a&gt; is a logging framework for Erlang and
it has become a de facto standard for Erlang applications.&lt;/p&gt;

&lt;p&gt;Usually, when you look through log files in Ruby (e.g. puma.log), you can say
&amp;ldquo;we started processing at XXX and finished at YYY&amp;rdquo; and it will be more or less
accurate.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;I, [2015-04-31T03:04:20.613116 #28143]  INFO -- : Started
...
I, [2015-04-31T03:04:21.345985 #28143]  INFO -- : Finished
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So the first thing I did, when I needed to find a bottleneck in one part of our
system, was looking at log timings. Wrong move!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2015-05-25 16:50:42.229 [info] Started
2015-05-25 16:50:42.235 [info] Finished
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6ms - wow!&lt;/p&gt;

&lt;p&gt;It is like an old shabby van with free candies. You have a feeling that
something is not right.&lt;/p&gt;

&lt;p&gt;And when I had used &lt;code&gt;timer:tc&lt;/code&gt; (analog in Ruby - &lt;code&gt;Benchmark&lt;/code&gt;), these timings
proved to be &amp;ldquo;wrong&amp;rdquo;. And that&amp;rsquo;s because in Erlang, logger (as most things) is
a separate process with its own mailbox. What you see are &lt;strong&gt;the times of when
it received the messages&lt;/strong&gt;. In contrast, things are usually happening in the
same thread in Ruby (that is why timings are usually more accurate).&lt;/p&gt;

&lt;div style=&#34;align:center&#34;&gt;
  &lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2015-08-03-from-ruby-to-erlang/lager1.png&#34; alt=&#34;&#34;/ width=&#34;100%&#34; title=&#34;&#34;&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Lesson #2. Do not rely on lager timings, because it is a separate gen_server (i.e. you don’t know when it will process your messages).&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-high-loaded-gen-server&#34;&gt;3. High-loaded gen_server&lt;/h2&gt;

&lt;p&gt;This is more like a word of advice. When you have a &lt;code&gt;gen_server&lt;/code&gt;, which is
supposed to process, say, 1000 events per second, you can&amp;rsquo;t make any
synchronous blocking calls (e.g. to Redis) or set any locks, because soon
enough the process mailbox will be full of messages and things will become
ugly.&lt;/p&gt;

&lt;p&gt;What you should do instead, is to spawn a process per unit (an order or
something like that) or use a worker pool (&lt;a href=&#34;https://github.com/devinus/poolboy&#34;&gt;1&lt;/a&gt;,&lt;a href=&#34;https://github.com/seth/pooler&#34;&gt;2&lt;/a&gt;,&lt;a href=&#34;https://github.com/inaka/worker_pool&#34;&gt;3&lt;/a&gt;). I personally
recommend to watch &lt;a href=&#34;https://www.youtube.com/watch?v=GO_97_6w5lU&#34;&gt;this talk&lt;/a&gt; by Anthony Molinaro at Erlang Factory SF
2015, where he compares a few different options we have at the moment.&lt;/p&gt;

&lt;p&gt;If you also had some troubles during transition to another language, let me
know. I personally laugh at such moments and don&amp;rsquo;t take them too seriously,
because, you know, it just happens sometimes. The important is to learn by
these mistakes.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Разрабатываем ruby gem в docker контейнере</title>
      <link>http://homeonrails.com/2015/05/razrabatyvaiem-ruby-gem-v-docker-kontieinierie/</link>
      <pubDate>Thu, 07 May 2015 11:53:25 +0000</pubDate>
      
      <guid>http://homeonrails.com/2015/05/razrabatyvaiem-ruby-gem-v-docker-kontieinierie/</guid>
      <description>&lt;p&gt;&lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2015-05-07-razrabatyvaiem-ruby-gem-v-docker-kontieinierie/logo.png&#34; alt=&#34;&#34;/ width=&#34;450&#34; title=&#34;Разрабатываем ruby gem в docker контейнере&#34;&gt;&lt;/p&gt;

&lt;p&gt;Контейнеры захватывают вселенную, и ничего с этим не поделаешь. Несмотря на то,
что я являюсь старым приверженцем Vagrant&amp;rsquo;а, на днях мне все же захотелось
попробовать docker для одного из своих проектов -
&lt;a href=&#34;https://github.com/kaize/valle&#34;&gt;Valle&lt;/a&gt;. Не без препонов, но все же удалось
встроить docker в процесс. Далее последует руководство по разработке Ruby гема
с использованием docker&amp;rsquo;а.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Небольшое отступление&lt;/em&gt;: я не знаю кто победит в битве тулов - docker или
rocket и КО, которые недавно выпустили общую спецификацию на контейнеры - &lt;a href=&#34;https://github.com/appc/spec&#34;&gt;App
Container&lt;/a&gt;, или еще кто-то. Пусть победит
сильнейший. docker я выбрал по 2 причинам: 1) он уже давно стабилен и вполне
годен для повседневного использования (для разработки точно) 2) это довольно
большая платформа с кучей готовых рецептов и туториалов.&lt;/p&gt;

&lt;h3 id=&#34;1-устанавливаем-docker&#34;&gt;1. Устанавливаем docker&lt;/h3&gt;

&lt;p&gt;Все команды актуальны для Ubuntu. Инструкции для других ОС читайте на
официальных сайтах.&lt;/p&gt;

&lt;p&gt;И так, начнем. Первым делом нам надо установить сам docker (для других ОС см.
&lt;a href=&#34;http://docs.docker.com/installation/&#34;&gt;инструкцию&lt;/a&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ wget -qO- https://get.docker.com/ | sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Чтобы каждый раз не писать sudo при его использовании, создадим группу docker и
добавим своего пользователя в нее:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ sudo usermod -aG docker &amp;lt;username&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-создаем-dockerfile&#34;&gt;2. Создаем Dockerfile&lt;/h3&gt;

&lt;p&gt;Следующим нашим шагом будет создание Dockerfile&amp;rsquo;а для нашего гема. Создайте
Dockerfile со следующим содержимым в корне вашего гема:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;# Dockerfile
FROM ruby:2.2.2

RUN mkdir -p /usr/src/lib
WORKDIR /usr/src/lib

COPY Gemfile* /usr/src/lib/
COPY *.gemspec /usr/src/lib/
RUN bundle install

COPY . /usr/src/lib/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Вы можете натолкнуться на ошибку мол &amp;ldquo;Не могу найти lib/&lt;yourgemname\&gt;/version.rb&amp;rdquo; если
загружаете его (файл с версией) в gemspec файле. Решением будет добавить еще
одну инструкцию COPY перед bundle install или &lt;a href=&#34;https://github.com/kaize/valle/commit/cfb4e8e451c54bb94176577811de72a01740d501#diff-6e266e394c50981ec99b03694aa7ccc0L2&#34;&gt;удалить
его к чертям&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;RUN mkdir -p /usr/src/lib/&amp;lt;yourgemname&amp;gt;
COPY lib/&amp;lt;yourgemname&amp;gt;/version.rb /usr/src/lib/&amp;lt;yourgemname&amp;gt;/version.rb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Если вы только начинаете разрабатывать гем и вам нужно создать его скелет выполните:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ docker run -it --rm --user &amp;quot;$(id -u):$(id -g)&amp;quot; -v &amp;quot;$PWD&amp;quot;:/usr/src/lib -w /usr/src/lib ruby:2.2.2 bundle gem &amp;lt;yourgemname&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Эта команда создаст поддиректорию &lt;yourgemname\&gt; внутри текущей.&lt;/p&gt;

&lt;p&gt;По умолчанию COPY скопирует все файлы и папки внутрь контейнера. Хорошей
практикой считается добавление .dockerignore в проект (как .gitignore,
только для docker&amp;rsquo;а):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# .dockerignore
pkg/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Также можно заморозить bundler, чтобы он выкидывал ошибку каждый раз, когда вы
пытаетесь запустить что-то при измененном Gemfile. То есть, вам придется
выполнить &lt;code&gt;bundle install&lt;/code&gt; и пересобрать контейнер (опционально).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;# Dockerfile
FROM ruby:2.2.2

# throw errors if Gemfile has been modified since Gemfile.lock
RUN bundle config --global frozen 1

...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;bundle install&lt;/code&gt; выполняем так:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ docker run --rm -v &amp;quot;$PWD&amp;quot;:/usr/src/lib -w /usr/src/lib ruby:2.2.2 bundle install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Другие хорошие практики можно прочесть здесь - &lt;a href=&#34;https://docs.docker.com/articles/dockerfile_best-practices/&#34;&gt;Best practices for writing
Dockerfiles&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-собираем-контейнер-и-запускаем-тесты&#34;&gt;3. Собираем контейнер и запускаем тесты&lt;/h3&gt;

&lt;p&gt;Результирующий Dockerfile должен выглядеть примерно так:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;# Dockerfile
FROM ruby:2.2.2

# throw errors if Gemfile has been modified since Gemfile.lock
RUN bundle config --global frozen 1

RUN mkdir -p /usr/src/lib
WORKDIR /usr/src/lib

COPY Gemfile* /usr/src/lib/
COPY *.gemspec /usr/src/lib/
RUN bundle install

COPY . /usr/src/lib/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Теперь соберем наш контейнер:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ docker build -t &amp;lt;yourgemname&amp;gt; .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;И запустим тесты:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ docker run -it --rm -v &amp;quot;$PWD&amp;quot;:/usr/src/lib &amp;lt;yourgemname&amp;gt; bundle exec rake
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Все должно отработать без проблем.&lt;/p&gt;

&lt;h3 id=&#34;4-makefile-опционально&#34;&gt;4. Makefile (опционально)&lt;/h3&gt;

&lt;p&gt;Хорошей идеей также будет добавить Makefile:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;docker_build:
	docker build -t &amp;lt;yourgemname&amp;gt; .

docker_test:
	docker run -it --rm -v &amp;quot;$(PWD)&amp;quot;:/usr/src/lib &amp;lt;yourgemname&amp;gt; bundle exec rake

.PHONY: docker_build docker_test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;или использовать &lt;a href=&#34;https://docs.docker.com/compose/&#34;&gt;docker-compose&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;5-результаты&#34;&gt;5. Результаты&lt;/h3&gt;

&lt;p&gt;Все это работает очень шустро (по крайней мере на моем Linux&amp;rsquo;е). Поговаривают,
что на маках ситуация чуть хуже по понятным причинам.&lt;/p&gt;

&lt;p&gt;Таким образом, все что потребуется от нашего коллеги или контрибьютора для
старта работы над гемом - это выполнить пару команд! Я считаю это здорово. Нет,
вы конечно можете добавить Vagrantfile вместе  с provisioning, но виртуалки
тяжелые и съедают много ресурсов. Или сказать, что для работы над гемом вам
нужно поставить Ruby, libXX1 и libXX2 ручками. Но и у этого подхода имеются
серьезные недостатки.&lt;/p&gt;

&lt;p&gt;Полезные ссылки:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/reference/#reference&#34;&gt;https://docs.docker.com/reference/#reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://registry.hub.docker.com/_/ruby/&#34;&gt;https://registry.hub.docker.com/_/ruby/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://registry.hub.docker.com/_/rails/&#34;&gt;https://registry.hub.docker.com/_/rails/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://robots.thoughtbot.com/rails-on-docker&#34;&gt;https://robots.thoughtbot.com/rails-on-docker&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Shamrock</title>
      <link>http://homeonrails.com/2015/02/shamrock/</link>
      <pubDate>Tue, 17 Feb 2015 10:05:37 +0000</pubDate>
      
      <guid>http://homeonrails.com/2015/02/shamrock/</guid>
      <description>&lt;p&gt;Бывают случаи, когда WebMock&amp;rsquo;а недостаточно, или же вы просто не любите stub&amp;rsquo;ы
и хотите, чтобы тест делал реальный http запрос. В таких случаях вы можете
написать свой &lt;a href=&#34;https://practicingruby.com/articles/implementing-an-http-file-server&#34;&gt;простенький http
сервер&lt;/a&gt;
или выбрать один из существующих, и стартовать его на время тестов(а). А можно
взять готовую библиотеку - &lt;a href=&#34;https://github.com/jsl/shamrock&#34;&gt;Shamrock&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Она принимает на вход любое Rack приложение и запускает его в отдельном треде с
помощью WEBrick&amp;rsquo;а. Порт можно задать самому. В противном случае будет
использован первый свободный.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def setup
  json = load_fixture(&amp;quot;service/200.json&amp;quot;)
  my_rack_app = proc {|env| [200, {&amp;quot;Content-Type&amp;quot; =&amp;gt; &amp;quot;application/json&amp;quot;}, [json]]}
  @service = Shamrock::Service.new(my_rack_app)
  @service.start
  @service.uri    # =&amp;gt; #&amp;lt;URI::HTTP http://localhost:54321&amp;gt;
end

def teardown
  @service.stop
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Доступные параметры у Service#new:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;handler&lt;/code&gt; - обработчик, который запускает Rack приложение (по умолчанию Rack::Handler::WEBrick)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;port&lt;/code&gt; - порт&lt;/li&gt;
&lt;li&gt;&lt;code&gt;monitor&lt;/code&gt; - монитор, который блокируется до тех пор, пока сервер не стартанет&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Вообще, либа написана хорошо, и выполняет именно то, что от нее ждут. Правда
популярности ей это не принесло :)&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Ruby speed quiz explained</title>
      <link>http://homeonrails.com/2014/04/ruby-speed-quiz-explained/</link>
      <pubDate>Tue, 01 Apr 2014 23:47:38 +0000</pubDate>
      
      <guid>http://homeonrails.com/2014/04/ruby-speed-quiz-explained/</guid>
      <description>&lt;p&gt;At the end of &lt;a href=&#34;http://homeonrails.com/2014/03/ruby-speed-quiz/&#34;&gt;Ruby speed quiz&lt;/a&gt; I promised to publish an explanation for each case.
I did not expect that more than 900 Rubyists will give it a shot. I
was surprised. Thanks to all who participated!&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;But lets go back to the questions.&lt;/p&gt;

&lt;h1 id=&#34;1-range-cover-vs-include&#34;&gt;1. Range cover? VS include?&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(&#39;a&#39;..&#39;z&#39;).cover?(&#39;f&#39;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(&#39;a&#39;..&#39;z&#39;).include?(&#39;f&#39;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;both run with the similar speed&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;cover? is faster&lt;/strong&gt; because it just finds out if the argument is &amp;gt; than the first and &amp;lt; the second.
No looping necessary. include?, in opposite, loops through all elements of the range until it
finds an argument or reaches the end.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;(&#39;a&#39;..&#39;z&#39;).cover?(&#39;f&#39;)
==&amp;gt; &#39;a&#39; &amp;lt;= &#39;f&#39; &amp;amp;&amp;amp; &#39;f&#39; &amp;lt;= &#39;z&#39;

(&#39;a&#39;..&#39;z&#39;).include?(&#39;f&#39;)
==&amp;gt; &#39;a&#39; == &#39;f&#39;
==&amp;gt; &#39;b&#39; == &#39;f&#39;
==&amp;gt; &#39;c&#39; == &#39;f&#39;
==&amp;gt; &#39;d&#39; == &#39;f&#39;
==&amp;gt; &#39;e&#39; == &#39;f&#39;
==&amp;gt; &#39;f&#39; == &#39;f&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;caveats&#34;&gt;Caveats&lt;/h3&gt;

&lt;p&gt;Be careful when using include? and cover?:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;(&#39;a&#39;..&#39;z&#39;).include?(&#39;blah&#39;)
# =&amp;gt; false
(&#39;a&#39;..&#39;z&#39;).cover?(&#39;blah&#39;)
# =&amp;gt; true
&#39;a&#39; &amp;lt; &#39;blah&#39;
# =&amp;gt; true
&#39;blah&#39; &amp;lt; &#39;z&#39;
# =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See &lt;a href=&#34;http://gistflow.com/posts/816-range-include-vs-range-cover&#34;&gt;this post&lt;/a&gt; for detailed benchmarks.&lt;/p&gt;

&lt;h1 id=&#34;2-blk-call-vs-yield&#34;&gt;2. blk.call VS yield&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def foo
  yield if block_given?
end
foo { puts &amp;quot;Hi from foo&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def bar(&amp;amp;blk)
  blk.call
end
bar { puts &amp;quot;Hi from bar&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;both run with the similar speed&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;yield is faster&lt;/strong&gt; because the process of procifying a block takes time.&lt;/p&gt;

&lt;p&gt;See &lt;a href=&#34;http://mudge.name/2011/01/26/passing-blocks-in-ruby-without-block.html&#34;&gt;this post&lt;/a&gt; for detailed benchmarks.&lt;/p&gt;

&lt;h1 id=&#34;3-hash-vs-fetch&#34;&gt;3. Hash [] VS fetch&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;h = {}
h[:a] || 1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;h = {}
h.fetch(:a, 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;both run with the similar speed&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Using brackets to get goodies out of a hash is the same as fetch because they both use the same code to do exactly the same thing.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;if (!RHASH(hash)-&amp;gt;ntbl || !st_lookup(RHASH(hash)-&amp;gt;ntbl, key, &amp;amp;val)) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It checks that the hash is not empty and tries to find the value using a
given key.&lt;/p&gt;

&lt;h1 id=&#34;4-define-method-vs-class-eval-definition-not-call-speed&#34;&gt;4. define_method VS class_eval (definition, NOT call speed)&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class A
  100.times do |i|
    define_method(&amp;quot;foo_#{i}&amp;quot;) { 10.times.map { &amp;quot;foo&amp;quot;.length } }
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class B
  100.times do |i|
    class_eval &#39;def bar_#{i}; 10.times.map { &amp;quot;foo&amp;quot;.length }; end&#39;
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;both run with the similar speed&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Define method is faster&lt;/strong&gt; because you don&amp;rsquo;t have to eval the class and then define a method on it. You are already in the class scope. Also on each call to class_eval, MRI creates a new parser and parses the string. In the define_method case, the parser is only run once.&lt;/p&gt;

&lt;p&gt;However, it&amp;rsquo;s not that simple. Yes, define_method creates the method faster. But after creation, a short method created with class_eval is usually faster than one created with define_method. That is why you still can find many class_eval instructions
in Rails. These are places where run (not startup) speed matters. So, it&amp;rsquo;s worthwhile to chose based on your use case.&lt;/p&gt;

&lt;p&gt;See &lt;a href=&#34;http://tenderlovemaking.com/2013/03/03/dynamic_method_definitions.html&#34;&gt;this post&lt;/a&gt; for detailed benchmarks.&lt;/p&gt;

&lt;h1 id=&#34;5-super-with-or-without-arguments&#34;&gt;5. super with OR without arguments&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Parent
 def bar(a, b)
   puts &amp;quot;#{a} - #{b}&amp;quot;
 end
end

class Child &amp;lt; Parent
 def bar(a, b)
   super
 end
end
c = Child.new
c.bar(1, 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Parent
  def bar(a, b)
    puts &amp;quot;#{a} - #{b}&amp;quot;
  end
end

class Child &amp;lt; Parent
  def bar(a, b)
    super(a, b)
  end
end
c = Child.new
c.bar(1, 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;both run with the similar speed&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Calling super without arguments passes any arguments along that were passed through to the calling method. So it deals with arguments anyways.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Ruby speed quiz</title>
      <link>http://homeonrails.com/2014/03/ruby-speed-quiz/</link>
      <pubDate>Fri, 28 Mar 2014 12:13:48 +0000</pubDate>
      
      <guid>http://homeonrails.com/2014/03/ruby-speed-quiz/</guid>
      <description>&lt;p&gt;For each case choose the fastest option.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Platform, which hosted this quiz was closed. So it will be read only for some time.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;1-range-cover-vs-include&#34;&gt;1. Range cover? VS include?&lt;/h3&gt;

&lt;p&gt;1)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;(&#39;a&#39;..&#39;z&#39;).include?(&#39;f&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;(&#39;a&#39;..&#39;z&#39;).cover?(&#39;f&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3) both run with similar speed&lt;/p&gt;

&lt;h3 id=&#34;2-blk-call-vs-yield&#34;&gt;2. blk.call VS yield&lt;/h3&gt;

&lt;p&gt;1)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def foo
  yield if block_given?
end
foo { puts &amp;quot;Hi from foo&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2) both run with similar speed&lt;/p&gt;

&lt;p&gt;3)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def bar(&amp;amp;blk)
  blk.call
end
bar { puts &amp;quot;Hi from bar&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-hash-vs-fetch&#34;&gt;3. Hash [] VS fetch&lt;/h3&gt;

&lt;p&gt;1)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;h = {}
h[:a] || 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;h = {}
h.fetch(:a, 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3) both run with similar speed&lt;/p&gt;

&lt;h3 id=&#34;4-super-with-or-without-arguments&#34;&gt;4. super with OR without arguments&lt;/h3&gt;

&lt;p&gt;1)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Parent
  def bar(a, b)
    puts &amp;quot;#{a} - #{b}&amp;quot;
  end
end

class Child &amp;lt; Parent
  def bar(a, b)
    super(a, b)
  end
end
c = Child.new
c.bar(1, 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2) both run with similar speed&lt;/p&gt;

&lt;p&gt;3)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Parent
 def bar(a, b)
   puts &amp;quot;#{a} - #{b}&amp;quot;
 end
end

class Child &amp;lt; Parent
 def bar(a, b)
   super
 end
end
c = Child.new
c.bar(1, 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-define-method-vs-class-eval-definition-not-call-speed&#34;&gt;5. define_method VS class_eval (definition, NOT call speed)&lt;/h3&gt;

&lt;p&gt;1)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class A
  100.times do |i|
    define_method(&amp;quot;foo_#{i}&amp;quot;) { 10.times.map { &amp;quot;foo&amp;quot;.length } }
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class B
  100.times do |i|
    class_eval &#39;def bar_#{i}; 10.times.map { &amp;quot;foo&amp;quot;.length };
end&#39;
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3) both run with similar speed&lt;/p&gt;

&lt;p&gt;Check yourself:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;2&lt;/li&gt;
&lt;li&gt;1&lt;/li&gt;
&lt;li&gt;3&lt;/li&gt;
&lt;li&gt;2&lt;/li&gt;
&lt;li&gt;1&lt;/li&gt;
&lt;/ol&gt;

&lt;hr&gt;

&lt;p&gt;&lt;a href=&#34;http://homeonrails.com/2014/04/ruby-speed-quiz-explained/&#34;&gt;Here&lt;/a&gt; you could find an explanation for each case.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Don&#39;t do this at home on Rails #3</title>
      <link>http://homeonrails.com/2013/01/dont-do-this-at-home-on-rails-3/</link>
      <pubDate>Sat, 05 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>http://homeonrails.com/2013/01/dont-do-this-at-home-on-rails-3/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;Languages: Ruby&lt;/li&gt;
&lt;li&gt;Difficulty: &lt;span class=&#34;label label-success&#34;&gt;Easy&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A lot of time has passed since my last post, so I decided to fix this
little drawback. Next, we will discuss three small pieces of code,
which smells not very good. Let&amp;rsquo;s see what we can do about it.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;1-vulnerabilities-in-code&#34;&gt;#1 - Vulnerabilities in code&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s take a closer look at two methods from the controller:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def show_with_fragments
  constant = get_constant_from_param
  if constant
    obj = constant.find(params[:id])
    data = obj.attributes
    data.merge!(:telecasts =&amp;gt; obj.telecasts.map(&amp;amp;:as_json)) if obj.is_a?(TvShow::Programme)
    data.merge!(:seasons =&amp;gt; obj.seasons.map(&amp;amp;:as_json)) if obj.is_a?(TvShow::Serial)
    render :json =&amp;gt; data
  else
    render :json =&amp;gt; {}
  end
end

private

def get_constant_from_param(type = nil)
  param = type || params[:type]
  begin
    constant = param.constantize
    constant if constant &amp;lt; ActiveRecord::Base
  rescue NameError
    nil
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, what happens here?&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We receive the type of the model (&lt;code&gt;params[:type]&lt;/code&gt;) and convert string
to a constant using &lt;a href=&#34;http://apidock.com/rails/v3.2.8/ActiveSupport/Inflector/constantize&#34;&gt;constantize&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;We find the record with a given id (&lt;code&gt;params[:id]&lt;/code&gt;) and select all its
attributes and attributes of the associated objects.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We expect that the &lt;code&gt;type&lt;/code&gt; will be either &amp;ldquo;TvShow::Programme&amp;rdquo; or &amp;ldquo;TvShow::Serial&amp;rdquo;.
But what if &lt;code&gt;type&lt;/code&gt; will be &amp;ldquo;User&amp;rdquo;. We will get access to all the attributes of the
&lt;code&gt;User&lt;/code&gt; model. This is a serious security issue in our application.&lt;/p&gt;

&lt;p&gt;The first step is to limit &lt;code&gt;type&lt;/code&gt; to the &lt;code&gt;TvShow&lt;/code&gt; class descendants only.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def show_with_fragments
  constant = get_constant_from_param
  unless constant.is_a?(TvShow)
    raise ArgumentError, “type should be TvShow class descendant”
  end
  if constant
    obj = constant.find(params[:id])
    data = obj.attributes
    data.merge!(:telecasts =&amp;gt; obj.telecasts.map(&amp;amp;:as_json)) if obj.is_a?(TvShow::Programme)
    data.merge!(:seasons =&amp;gt; obj.seasons.map(&amp;amp;:as_json)) if obj.is_a?(TvShow::Serial)
    render :json =&amp;gt; data
  else
    render :json =&amp;gt; {}
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above violates &lt;a href=&#34;http://en.wikipedia.org/wiki/Open/closed_principle&#34;&gt;OCP&lt;/a&gt;
principe. Because we want to take advantage of polymorphism,
lets move the logic of getting the attributes of associated
objects into the classes themselves (see &lt;code&gt;complete_attributes_json&lt;/code&gt; method).
This will allow us to remove all those ugly is_a? checks.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def show_with_fragments
  constant = get_constant_from_param
  unless constant.is_a?(TvShow)
    raise ArgumentError, “type param should be TvShow accessor class”
  end
  if constant
    obj = constant.find(params[:id])
    render :json =&amp;gt; obj.complete_attributes_json
  else
    render :json =&amp;gt; {}
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looks better, right?&lt;/p&gt;

&lt;h3 id=&#34;2-take-advantage-of-yaml-language&#34;&gt;#2 - Take advantage of YAML language&lt;/h3&gt;

&lt;p&gt;Despite the fact that most of rails applications (and others) using
&lt;a href=&#34;http://en.wikipedia.org/wiki/YAML&#34;&gt;YAML&lt;/a&gt; to store the translations and settings,
not many of us knows all its features. Two features that
distinguish YAML from the capabilities of other data serialization languages
​​are Relational trees and Data Typing. The most interesting is the first one.
It allows us to attach the anchors (&amp;amp;) on the elements and refer to them
using references (*). To understand this, it is useful to imagine
a document as a tree.&lt;/p&gt;

&lt;p&gt;For example, here is some common locale file &lt;code&gt;config/locales/en.yml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;en:
  helpers:
    submit:
      product:
        create: &#39;Create it&#39;
        update: &#39;Save it&#39;
      product_item:
        create: &#39;Create it&#39;
        update: &#39;Save it&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What if we could define the translations for helpers &lt;code&gt;create&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt;
in one place, and then use them in other cases. Usually these translations
rarely changes, so, in this case, this is just what we need.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;en:
  helpers:
    submit:
      product:
        create: &amp;amp;create &#39;Create it&#39;
        update: &amp;amp;update &#39;Save it&#39;
      product_item:
        create: *create
        update: *update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have created two anchors and referred to them inside product_item
through two links. Advantages: avoiding possible errors (define
in one place) and compactness. Also, in future, if the translation will needs
to be changed, we wont spend much time to perform the appropriate changes.&lt;/p&gt;

&lt;p&gt;You can anchor not only tree nodes, but also the whole branches:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;common: &amp;amp;COMMON
  adapter: postgresql
  encoding: unicode
  pool: 10

development:
  &amp;lt;&amp;lt;: *COMMON
  database: db_name
  username: postgres
  password:
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-look-for-existing-method-before-writing-your-own&#34;&gt;#3 - Look for existing method before writing your own&lt;/h3&gt;

&lt;p&gt;Maybe I&amp;rsquo;m repeating myself, but this is exactly the case where repetition
will only benefit.&lt;/p&gt;

&lt;p&gt;Before you write any functionality, that is not relevant to the
application&amp;rsquo;s business logic, it is always better to look, maybe someone
has already implemented it. And very often it is. All we are know the
advantages of using existing solutions (libraries). And I think, if you like
it (you can not see any obstacles - performance, memory, that can stop you),
it is better to use it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def keys_to_symbols(data)
  res = {}
  data.each do |k, v|
    res[k.to_sym] = v.is_a?(Hash) ? keys_to_symbols(v) : v
  end
  res
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I found this method in one controller. It takes the hash and symbolize all
the keys. This functionality already implemented in the &lt;code&gt;active_support&lt;/code&gt; gem,
which is also enabled by default in rails. The method we are looking for -
&lt;a href=&#34;http://apidock.com/rails/Hash/symbolize_keys&#34;&gt;symbolize_keys&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Null migration, or What to do when there are too many migrations</title>
      <link>http://homeonrails.com/2012/11/null-migration-or-what-to-do-when-there-are-too-many-migrations/</link>
      <pubDate>Sun, 18 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>http://homeonrails.com/2012/11/null-migration-or-what-to-do-when-there-are-too-many-migrations/</guid>
      <description>&lt;p&gt;Migrations are probably one of the most killer features of ActiveRecord.
They allow you to design the architecture of the database along with the
growth of your project. If you change your data model (&lt;a href=&#34;http://martinfowler.com/eaaCatalog/domainModel.html&#34;&gt;Domain Model&lt;/a&gt;),
you reflect that change in code and write a migration (or several migrations),
which will make the necessary actions on your database schema. This may be
creating a new table, deleting a column or adding an unique index.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UPD (2015-02-15)&lt;/strong&gt;: recently I have discovered a gem called
&lt;a href=&#34;https://github.com/jalkoby/squasher&#34;&gt;squasher&lt;/a&gt;, which, I presume, does exactly
what this article describes, so check it before continuing reading.&lt;/p&gt;

&lt;p&gt;There are many benefits of using migrations, which you should definitely know
about. For example, independency from a particular database or the ability to
easily switch between different states of the database using the rake commands
&lt;code&gt;db:migrate&lt;/code&gt; and &lt;code&gt;db:rollback&lt;/code&gt;. More detailed information about them you could
find in the &lt;a href=&#34;http://guides.rubyonrails.org/migrations.html&#34;&gt;RailsGuides Migrations&lt;/a&gt; article.&lt;/p&gt;

&lt;h2 id=&#34;the-problem&#34;&gt;The problem&lt;/h2&gt;

&lt;p&gt;Sooner or later, especially in the long-running projects, &lt;strong&gt;the number of
migrations exceeds any acceptable norms&lt;/strong&gt;. When they are 50, it is perfectly
acceptable. But in really big projects, their number can be up to 500 or even more.&lt;/p&gt;

&lt;h2 id=&#34;what-can-we-do&#34;&gt;What can we do?&lt;/h2&gt;

&lt;p&gt;Create a &lt;strong&gt;null migration&lt;/strong&gt; (or initial migration) - migration, which contains
all previous migrations, i.e. the current state of the database schema
(&lt;code&gt;db/schema.rb&lt;/code&gt; or &lt;code&gt;db/sctructure.sql&lt;/code&gt;, depending on the format). Thus,
we get &lt;strong&gt;one migration instead of several hundred&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Pros:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;only one migration&lt;/li&gt;
&lt;li&gt;increased the speed and, consequently, reduced the time for running migrations&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cons:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;large size of the null migration&lt;/li&gt;
&lt;li&gt;all migrations merged into one, so we cannot switch between them any more&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let me remind you that the format of the database schema is defined in
&lt;code&gt;config/application.rb&lt;/code&gt; file using &lt;code&gt;config.active_record.schema_format&lt;/code&gt; parameter.
Possible values ​​are &lt;code&gt;:ruby&lt;/code&gt; ​​or &lt;code&gt;:sql&lt;/code&gt;. The default is &lt;code&gt;:ruby&lt;/code&gt;. The main difference
between them is that the second one goes with support for the functions specific
to a particular database (e.g., PostgreSQL sequences).&lt;/p&gt;

&lt;p&gt;Next, I will show how you can create a null migration.&lt;/p&gt;

&lt;h2 id=&#34;creating-a-null-migration-schema-format-ruby&#34;&gt;Creating a null migration (schema format - &lt;code&gt;:ruby&lt;/code&gt;)&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Dump your schema&lt;/li&gt;
&lt;li&gt;Create a migration&lt;/li&gt;
&lt;li&gt;Change migration timestamp&lt;/li&gt;
&lt;li&gt;Remove previous migrations&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;1-dump-your-schema&#34;&gt;1. Dump your schema&lt;/h3&gt;

&lt;p&gt;In most cases, you should already have a file &lt;code&gt;db/schema.rb&lt;/code&gt;. If not, use the following rake task:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; rake db:schema:dump
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It should do the job.&lt;/p&gt;

&lt;h3 id=&#34;2-create-a-migration&#34;&gt;2. Create a migration&lt;/h3&gt;

&lt;p&gt;Create a new migration named &lt;code&gt;NullMigration&lt;/code&gt; using Rails generator:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; rails g migration NullMigration
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Open the newly created migration. It should look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class NullMigration &amp;lt; ActiveRecord::Migration
  def up
  end

  def down
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now copy the contents of the &lt;code&gt;ActiveRecord::Schema.define&lt;/code&gt; block from a file &lt;code&gt;db/schema.rb&lt;/code&gt; into the method &lt;code&gt;up&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It remains to take care of the method &lt;code&gt;down&lt;/code&gt;, which is responsible for
rolling back our migration. Sure, we can go through all migrations and
copy the content of all &lt;code&gt;down&lt;/code&gt; methods, but it is too expensive. Instead,
let&amp;rsquo;s make our first migration irreversible, especially, there is no much
sense in rolling back to an empty database (we can always delete and create the required
database using the rake command &lt;code&gt;db:drop db:create&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;As a result, the migration should look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class NullMigration &amp;lt; ActiveRecord::Migration
  def up
    create_table &amp;quot;table&amp;quot;, :force =&amp;gt; true do |t|
    ...
  end

  def down
    raise ActiveRecord::IrreversibleMigration
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-change-migration-timestamp&#34;&gt;3. Change migration timestamp&lt;/h3&gt;

&lt;p&gt;Now, if you&amp;rsquo;d try to run a migration, you will get an error, because we already
have all the structures (tables, indexes) in our database. ActiveRecord checks
migration state (whether it was executed or not) by looking into
&lt;code&gt;schema_migrations&lt;/code&gt; table. This table basically holds the timestamps of
all executed migrations.&lt;/p&gt;

&lt;p&gt;So, if we do not want ActiveRecord to run our null migration, we either
need to manually insert its timestamp or change it (timestamp) to the last
executed migration timestamp, which is much easier to do.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s do this.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Find the file with the last executed migration (migration before the null migration) and copy its timestamp&lt;/li&gt;
&lt;li&gt;Replace the null migration timestamp with it.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Alternatively, you can find the required timestamp inside the
&lt;code&gt;ActiveRecord::Schema.define(:version =&amp;gt; 20120925084251)&lt;/code&gt; block (or at the end of
&lt;code&gt;null_schema.sql&lt;/code&gt; in case of &lt;code&gt;:sql&lt;/code&gt; schema format)&lt;/p&gt;

&lt;p&gt;Example (using the command line):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; ls db/migrate

20120925084251_add_state_to_task_topics.rb
20121120080714_null_migration.rb

&amp;gt; mv 20121120080714_null_migration.rb 20120925084251_null_migration.rb
&amp;gt; ls db/migrate

20120925084251_add_state_to_task_topics.rb
20120925084251_null_migration.rb
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-remove-previous-migrations&#34;&gt;4. Remove previous migrations&lt;/h3&gt;

&lt;p&gt;Now you only have to remove the previous migrations. I think this you can do without my help :)&lt;/p&gt;

&lt;h2 id=&#34;creating-a-null-migration-schema-format-sql&#34;&gt;Creating a null migration (schema format - &lt;code&gt;:sql&lt;/code&gt;)&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Dump your schema&lt;/li&gt;
&lt;li&gt;Create a migration&lt;/li&gt;
&lt;li&gt;Change migration timestamp&lt;/li&gt;
&lt;li&gt;Remove previous migrations&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;1-dump-your-schema-1&#34;&gt;1. Dump your schema&lt;/h3&gt;

&lt;p&gt;This step is not much different from the above, with the exception of the
schema file - &lt;code&gt;db/structure.sql&lt;/code&gt; and rake command to dump the database:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; rake db:structure:dump
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Would like to note that, unlike the command &lt;code&gt;rake db:schema:dump&lt;/code&gt;, which uses
built-in ActiveRecord schema dumper, this command uses special tools
specific to a particular database (for example, pg_dump for PostgreSQL).&lt;/p&gt;

&lt;h3 id=&#34;2-create-a-migration-1&#34;&gt;2. Create a migration&lt;/h3&gt;

&lt;p&gt;Create a migration (see a similar step above). Next, copy the file
&lt;code&gt;db/structure.sql&lt;/code&gt; into folder &lt;code&gt;db/migrate&lt;/code&gt; and rename it to &lt;code&gt;null_schema.sql&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Our migration would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class NullMigration &amp;lt; ActiveRecord::Migration
  def up
    file_data = File.read(&#39;db/migrate/null_schema.sql&#39;)
    ActiveRecord::Base.connection.execute file_data
  end

  def down
    raise ActiveRecord::IrreversibleMigration
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-change-migration-timestamp-1&#34;&gt;3. Change migration timestamp&lt;/h3&gt;

&lt;h3 id=&#34;4-remove-previous-migrations-1&#34;&gt;4. Remove previous migrations&lt;/h3&gt;

&lt;h2 id=&#34;wrapping-up&#34;&gt;Wrapping Up&lt;/h2&gt;

&lt;p&gt;Creating a null migration - a convenient way to get rid of a large number
of migrations. Therefore, we become able to restart the database development
cycle, i.e. to start from scratch.&lt;/p&gt;

&lt;p&gt;I believe that null migration was invented a long time ago, but I could
not find anything on the internet on this subject, so decided to share with
you. If you have any questions or additions, be sure to leave them
in the comments to this article.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Thank you to Alexey Astafyev, Alexander Rozhnov and Igor Kuznetsov for reviewing this post.&lt;/em&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Tired of copying FactoryGirl sequences from project to project?</title>
      <link>http://homeonrails.com/2012/11/tired-of-copying-factorygirl-sequences-from-project-to-project/</link>
      <pubDate>Thu, 15 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>http://homeonrails.com/2012/11/tired-of-copying-factorygirl-sequences-from-project-to-project/</guid>
      <description>&lt;p&gt;Take a look at the
&lt;a href=&#34;http://rubygems.org/gems/factory_girl_sequences&#34;&gt;factory_girl_sequences&lt;/a&gt; gem,
which provides a basic set of the most common sequences.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;In simple projects without a complex business logic, you just need a set of
simple sequences to generate fake data. This can be a login, password or IP
address. The idea to write this mini gem came to me when I, again, was looking
for a sequence to generate the IP address. Of course, I could write it from
  scratch, but I&amp;rsquo;m a bit lazy :)&lt;/p&gt;

&lt;p&gt;In any case, check out the &lt;a href=&#34;http://git.io/b99NKA&#34;&gt;project page on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.rubyflow.com/items/8475-tired-of-copying-factorygirl-sequences-from-project-to-projec&#34;&gt;Original post on rubyflow.com&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Don&#39;t do this at home on Rails #2</title>
      <link>http://homeonrails.com/2012/11/dont-do-this-at-home-on-rails-2/</link>
      <pubDate>Sat, 10 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>http://homeonrails.com/2012/11/dont-do-this-at-home-on-rails-2/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;Languages: Ruby&lt;/li&gt;
&lt;li&gt;Difficulty: &lt;span class=&#34;label label-success&#34;&gt;Easy&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;Now is the time to break down the next three examples of code that look
slightly chapped, and just beg to be retouched. Despite the apparent
complexity, by running a series of easy refactorings, we can significantly
improve the code: reduce the size, improve the readability and even
increase its speed. Who knows?&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Well, let&amp;rsquo;s start.&lt;/p&gt;

&lt;h3 id=&#34;1-prefer-time-current-over-time-zone-now-or-time-zone&#34;&gt;#1 - prefer Time.current over Time.zone.now or Time.zone&lt;/h3&gt;

&lt;p&gt;Very often I see a code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;if schedulled_at &amp;gt; Time.zone.now
  ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And there is nothing wrong with it :) Seriously. But what if we have not set
the time zone? Most likely we&amp;rsquo;ll get an error. Just recently I came across a
method that does this check for us.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://apidock.com/rails/Time/current/class&#34;&gt;Time.current&lt;/a&gt; - returns
&lt;code&gt;Time.zone.now&lt;/code&gt; if the &lt;code&gt;Time.zone&lt;/code&gt; or &lt;code&gt;config.time_zone&lt;/code&gt; set,
otherwise just returns &lt;code&gt;Time.now&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;if schedulled_at &amp;gt; Time.current
  ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-avoid-using-before-filter&#34;&gt;#2 - Avoid using &lt;code&gt;before_filter&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;before_filter&lt;/code&gt; is used inside controllers to execute any code before any action
will be executed. This allows us to avoid duplicating code. But, like any tool,
it can be used &amp;ldquo;in the wrong way&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class SubscribesController &amp;lt; ApplicationController
  before_filter :load_subscribe, only: [:show, :destroy]

  def index
    @subscribes = Subscribe.all
  end

  def show
  end

  def destroy
    @subscribe.destroy
    redirect_to :root
  end

  private

    def load_subscribe
      @subscribe = Subscribe.find_by_name(params[:id]) || raise(ActiveRecord::RecordNotFound)
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I do not mind eliminating duplication, especially when the private method below
does consist of 40 lines, for example. I just think, logic should be more explicit
here. Otherwise, to understand what makes a particular action, the programmer
must first look at all before filters, then look at the methods that are
called by these filters and only then he or she comes to the action itself. This makes
the application logic confusing and difficult to understand.&lt;/p&gt;

&lt;p&gt;Before filters are really helpful in some cases. For example, when we need to check
whether the user is authorized or log each request.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class SubscribesController &amp;lt; ApplicationController
  def index
    @subscribes = Subscribe.all
  end

  def show
    load_subscribe
  end

  def destroy
    load_subscribe
    @subscribe.destroy
    redirect_to :root
  end

  private

  def load_subscribe
    @subscribe = Subscribe.find_by_name!(params[:id])
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you look at each action it doesn&amp;rsquo;t seem like the instance variables appear
magically. As the capabilities of a controller increases in size it becomes more
difficult to see the &amp;ldquo;magic&amp;rdquo; of a before filter hidden somewhere in the app
and the explicitness of method calling becomes very helpful.&lt;/p&gt;

&lt;p&gt;Note that I added &lt;code&gt;!&lt;/code&gt; sign to the &lt;code&gt;find_by_name&lt;/code&gt; method, which now throws an exception if the
corresponding record is not found. Next, I would probably get rid of the private
method, since it consists only of one line.&lt;/p&gt;

&lt;h3 id=&#34;3-use-powerful-enumerable-methods-example-with-select&#34;&gt;#3 - Use powerful &lt;code&gt;Enumerable&lt;/code&gt; methods (example with &lt;code&gt;select&lt;/code&gt;)&lt;/h3&gt;

&lt;p&gt;Module &lt;a href=&#34;http://ruby-doc.org/core-1.9.3/Enumerable.html&#34;&gt;Enumerable&lt;/a&gt; provides a
variety of methods for manipulating, traversing and searching though a
collection. It is very hard to remember them all, but that is not necessary.
What is required of us, is to simplify code by maximum.&lt;/p&gt;

&lt;p&gt;Now I will show you two main sources that help me every day:
- &lt;a href=&#34;http://apidock.com/&#34;&gt;APIdock&lt;/a&gt;
- &lt;a href=&#34;http://ruby-doc.org/core-1.9.3/&#34;&gt;Ruby 1.9.3 Doc&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# before
@groups = Group.all.find_all { |g| g.admin?(current_user) }
@projects = Project.all.find_all { |p| p.admin?(current_user) }

# after
@groups = Group.select { |g| g.admin?(current_user) }
@projects = Project.select { |p| p.admin?(current_user) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, the code has not changed much.
But, using such a bricks, we can build really powerful self-documenting code.&lt;/p&gt;

&lt;p&gt;After all, this leads to a reducing of complexity, which makes the code
transparent and flexible. As a result, we can do refactor
it without any problems.&lt;/p&gt;

&lt;p&gt;And that&amp;rsquo;s all for today folks!&lt;/p&gt;

&lt;h2 id=&#34;follow-up&#34;&gt;Follow up&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://homeonrails.com/2013/01/dont-do-this-at-home-on-rails-3&#34;&gt;Don&amp;rsquo;t do this at home on Rails #3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>AssociationCountValidator</title>
      <link>http://homeonrails.com/2012/10/associationcountvalidator/</link>
      <pubDate>Wed, 10 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>http://homeonrails.com/2012/10/associationcountvalidator/</guid>
      <description>&lt;p&gt;As a result of my &lt;a href=&#34;http://homeonrails.com/2012/10/validating-nested-associations-in-rails&#34;&gt;previous blog post&lt;/a&gt;
about validating nested associations, I wrote custom validator for Rails 3.
It is intended to help you to validate records count in a given association.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# lib/association_count_validator.rb
class AssociationCountValidator &amp;lt; ActiveModel::Validations::LengthValidator
  MESSAGES = { :wrong_length =&amp;gt; :association_count_invalid,
               :too_short =&amp;gt; :association_count_greater_than_or_equal_to,
               :too_long =&amp;gt; :association_count_less_than_or_equal_to }.freeze

  def initialize(options)
    MESSAGES.each { |key, message| options[key] ||= message }
    super
  end

  def validate_each(record, attribute, value)
    existing_records = record.send(attribute).reject(&amp;amp;:marked_for_destruction?)
    super(record, attribute, existing_records)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Probably, you noticed that this is just a wrapper over the standard &lt;code&gt;LengthValidator&lt;/code&gt;.
This has a big advantage - all options, provided by the basic validator, are supported.
And it correctly handles the situation with marked for destruction records,
which was mentioned in the previous post.&lt;/p&gt;

&lt;p&gt;Usage:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Company &amp;lt; ActiveRecord::Base
  OFFICES_COUNT_MIN = 1

  attr_accessible :name, :offices_attributes

  validates :name, presence: true
  validates :offices, association_count: { minimum: OFFICES_COUNT_MIN }

  has_many :offices, inverse_of: :company

  accepts_nested_attributes_for :offices, allow_destroy: true
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Do not forget to add custom error messages to your localization files.&lt;/p&gt;

&lt;p&gt;Example for &lt;code&gt;en&lt;/code&gt; culture:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;en:
  errors:
    messages:
      association_count_less_than_or_equal_to:
        one: count must be less than 1
        other: count must be less than or equal to %{count}
      association_count_greater_than_or_equal_to:
        one: count must be greater than 1
        other: count must be greater than or equal to %{count}
      association_count_invalid:
        one: count is invalid (must be equal to 1)
        other: count is invalid (must be equal to %{count})
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Validating nested associations in Rails</title>
      <link>http://homeonrails.com/2012/10/validating-nested-associations-in-rails/</link>
      <pubDate>Mon, 08 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>http://homeonrails.com/2012/10/validating-nested-associations-in-rails/</guid>
      <description>&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;Rails provide a wide range of options for creating rich forms for your models.
This can be a simple form for one object, or the form for many related objects.
Usually it is a parent-children relations. If you are not familiar with such terms
as &lt;a href=&#34;http://api.rubyonrails.org/classes/ActionView/Helpers/FormHelper.html#M001605&#34;&gt;form_for&lt;/a&gt;
or &lt;a href=&#34;http://api.rubyonrails.org/classes/ActiveRecord/NestedAttributes/ClassMethods.html#M002132&#34;&gt;accepts_nested_attributes_for&lt;/a&gt;,
I strongly recommend taking a look at this article &lt;a href=&#34;http://rubysource.com/complex-rails-forms-with-nested-attributes/&#34;&gt;Complex Rails Forms with Nested Attributes&lt;/a&gt;,
written by &lt;a href=&#34;http://xaviershay.com/&#34;&gt;Xavier Shay&lt;/a&gt;, which will show your how you can create complex forms with Rails.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;an-example&#34;&gt;An example&lt;/h2&gt;

&lt;p&gt;Suppose, we have a model called &lt;code&gt;Company&lt;/code&gt;. And the company may have several offices.
Lets define these two models.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Company &amp;lt; ActiveRecord::Base
  attr_accessible :name, :offices_attributes
  validates :name, presence: true
  has_many :offices
  accepts_nested_attributes_for :offices, allow_destroy: true
end

class Company::Office &amp;lt; ActiveRecord::Base
  attr_accessible :company_id, :name
  validates :name, presence: true
  belongs_to :company
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both company and office have names. The company could have zero or more offices.&lt;/p&gt;

&lt;p&gt;By including &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt; it becomes possible to access
offices attributes inside our &lt;code&gt;Company&lt;/code&gt; model.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; c = Company.create(name: &#39;Mars LLC&#39;)
&amp;gt;   =&amp;gt; #&amp;lt;Company id: 1, name: &amp;quot;Mars LLC&amp;quot;, created_at: &amp;quot;2012-10-08 19:16:44&amp;quot;, updated_at: &amp;quot;2012-10-08 19:16:44&amp;quot;&amp;gt;

# add two new offices
&amp;gt; c.offices_attributes = [{ name: &#39;North America&#39; }, { name: &#39;Europe&#39; }]
&amp;gt;   =&amp;gt; [{:name=&amp;gt;&amp;quot;North America&amp;quot;}, {:name=&amp;gt;&amp;quot;Europe&amp;quot;}]
&amp;gt; c.save
&amp;gt; c.offices
&amp;gt;   =&amp;gt; [#&amp;lt;Company::Office id: 1, company_id: 1, name: &amp;quot;North America&amp;quot;, created_at: &amp;quot;2012-10-08 19:21:54&amp;quot;, updated_at: &amp;quot;2012-10-08 19:21:54&amp;quot;&amp;gt;, #&amp;lt;Company::Office id: 2, company_id: 1, name: &amp;quot;Europe&amp;quot;, created_at: &amp;quot;2012-10-08 19:21:54&amp;quot;, updated_at: &amp;quot;2012-10-08 19:21:54&amp;quot;&amp;gt;]

# edit office in North America
&amp;gt; c.offices_attributes = [{ id: 1, name: &amp;quot;North America (it&#39;s cold out there)&amp;quot; }]
&amp;gt;   =&amp;gt; [{:id=&amp;gt;1, :name=&amp;gt;&amp;quot;North America (it&#39;s cold out there)&amp;quot;}]
&amp;gt; c.save
&amp;gt; c.offices
&amp;gt;   =&amp;gt; [#&amp;lt;Company::Office id: 1, company_id: 1, name: &amp;quot;North America (it&#39;s cold out there)&amp;quot;, created_at: &amp;quot;2012-10-08 19:21:54&amp;quot;, updated_at: &amp;quot;2012-10-08 19:25:18&amp;quot;&amp;gt;, #&amp;lt;Company::Office id: 2, company_id: 1, name: &amp;quot;Europe&amp;quot;, created_at: &amp;quot;2012-10-08 19:21:54&amp;quot;, updated_at: &amp;quot;2012-10-08 19:21:54&amp;quot;&amp;gt;]

# delete an office in Europe
&amp;gt; c.offices_attributes = [{ id: 2, _destroy: &#39;1&#39; }]
&amp;gt;   =&amp;gt; [{:id=&amp;gt;2, :_destroy=&amp;gt;&amp;quot;1&amp;quot;}]
&amp;gt; c.save
&amp;gt; c.offices
&amp;gt;   =&amp;gt; [#&amp;lt;Company::Office id: 1, company_id: 1, name: &amp;quot;North America (it&#39;s cold out there)&amp;quot;, created_at: &amp;quot;2012-10-08 19:21:54&amp;quot;, updated_at: &amp;quot;2012-10-08 19:25:18&amp;quot;&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two basic options, that you should know when dealing with &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;allow_destroy&lt;/code&gt; - allows to destroy objects (&lt;code&gt;false&lt;/code&gt; by default)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reject_if&lt;/code&gt; - rejects the records, based on the given  &lt;code&gt;Proc&lt;/code&gt; or
a &lt;code&gt;Symbol&lt;/code&gt; pointing to a method. This one is simular to the &lt;code&gt;Enumerable::reject&lt;/code&gt; method (&lt;a href=&#34;http://www.ruby-doc.org/core-1.9.3/Enumerable.html#method-i-reject&#34;&gt;Doc&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Take a look at the other supported options on &lt;a href=&#34;http://apidock.com/rails/ActiveRecord/NestedAttributes/ClassMethods/accepts_nested_attributes_for&#34;&gt;apidock.com&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;validating-nested-attributes&#34;&gt;Validating nested attributes&lt;/h3&gt;

&lt;p&gt;Except the basic validation, you can use &lt;code&gt;reject_if&lt;/code&gt; option to validate a nested object.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Company &amp;lt; ActiveRecord::Base
  attr_accessible :name, :offices_attributes
  validates :name, presence: true
  has_many :offices
  accepts_nested_attributes_for :offices, allow_destroy: true, reject_if: :office_name_invalid

  private

    def office_name_invalid(attributes)
      # office name shouldn&#39;t start with underscore
      attributes[&#39;name&#39;] =~ /\A_/
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The method should return either true (rejects the record) or false.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; c.offices_attributes = [{ id: 1, name: &#39;_North America&#39;}]
&amp;gt;   =&amp;gt; [{:id=&amp;gt;1, :name=&amp;gt;&amp;quot;_North America&amp;quot;}]
&amp;gt; c.save
&amp;gt; c.offices # no changes
&amp;gt;   =&amp;gt; [#&amp;lt;Company::Office id: 1, company_id: 1, name: &amp;quot;North America&amp;quot;, created_at: &amp;quot;2012-10-08 19:21:54&amp;quot;, updated_at: &amp;quot;2012-10-08 19:46:22&amp;quot;&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could use predefined &lt;code&gt;:all_blank&lt;/code&gt; symbol.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; c.offices_attributes = [{ name: &#39;&#39;}]
&amp;gt;   =&amp;gt; [{:name=&amp;gt;&amp;quot;&amp;quot;}]
&amp;gt; c.save
&amp;gt; c.offices # no changes
&amp;gt;   =&amp;gt; [#&amp;lt;Company::Office id: 1, company_id: 1, name: &amp;quot;North America&amp;quot;, created_at: &amp;quot;2012-10-08 19:21:54&amp;quot;, updated_at: &amp;quot;2012-10-08 19:46:22&amp;quot;&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Passing &lt;code&gt;:all_blank&lt;/code&gt; instead of a Proc will create a proc that will reject a record where all the attributes are blank excluding any value for &lt;code&gt;_destroy&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;validating-count-of-the-nested-attributes&#34;&gt;Validating count of the nested attributes&lt;/h3&gt;

&lt;p&gt;Lets add more complexity to our company model and say for example: it &lt;strong&gt;must have at least one
office&lt;/strong&gt; (we usually called it the main office).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Company &amp;lt; ActiveRecord::Base
  OFFICES_COUNT_MIN = 1

  attr_accessible :name, :offices_attributes
  validates :name, presence: true
  validate do
    check_offices_number
  end
  has_many :offices
  accepts_nested_attributes_for :offices, allow_destroy: true

  private

    def offices_count_valid?
      offices.count &amp;gt;= OFFICES_COUNT_MIN
    end

    def check_offices_number
      unless offices_count_valid?
        errors.add(:base, :offices_too_short, :count =&amp;gt; OFFICES_COUNT_MIN)
      end
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem here is that accepts_nested_attributes_for call destroy for child
objects &lt;strong&gt;AFTER&lt;/strong&gt; validation of the parent object. So the user is able to delete
an office. Of course, later, when the user will try to edit a company,
he/she will get an error - &amp;ldquo;Company should have at least one office.&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://homeonrails.com/images/posts/2012-10-08-validating-nested-associations-in-rails/flowchart.png&#34; alt=&#34;Flowchart of the validation process&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; c.offices_attributes = [{ id: 1, _destroy: &#39;1&#39; }]
&amp;gt;   =&amp;gt; [{:id=&amp;gt;1, :_destroy=&amp;gt;&amp;quot;1&amp;quot;}]
&amp;gt; c.save
&amp;gt; c.offices
&amp;gt;   =&amp;gt; []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You could try to use standard &lt;code&gt;length&lt;/code&gt; validator
(e.g. &lt;code&gt;validates :offices, length: { minimum: OFFICES_COUNT_MIN }&lt;/code&gt;), and it actually works,
but again, it does not take into account the fact that some of the records may
be marked for destruction.&lt;/p&gt;

&lt;p&gt;The things are getting a little tricky here.
To sort out the problem, we need to understand what &lt;code&gt;offices_attributes=&lt;/code&gt; method does.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# accepts_nested_attributes_for generates for us this method
def offices_attributes=(attributes)
  # @note the name of the method to call may vary depending on the type of association
  # @see https://github.com/rails/rails/blob/master/activerecord/lib/active_record/nested_attributes.rb#L285
  assign_nested_attributes_for_collection_association(:offices, attributes, mass_assignment_options)
end

def assign_nested_attributes_for_collection_association
  ...
  if !call_reject_if(association_name, attributes) # if the record passed
    # update a record with the attributes or marks it for destruction
    assign_to_or_mark_for_destruction(existing_record, attributes, options[:allow_destroy], assignment_opts)
  end
  ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see from the code above, our method marks offices records (with &lt;code&gt;_destroy&lt;/code&gt; attribute) for destruction.
When the company validates offices count, the offices relation includes &lt;strong&gt;all&lt;/strong&gt; the records.
So, all we need to do is to select only those records not marked for destruction.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Company &amp;lt; ActiveRecord::Base
  ...

  private

    def offices_count_valid?
      offices.reject(&amp;amp;:marked_for_destruction?).count &amp;gt;= OFFICES_COUNT_MIN
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we&amp;rsquo;ve got the actual number of the company&amp;rsquo;s offices. Therefore, we will get an error while trying to delete the last office in North America:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; c.offices_attributes = [{ id: 1, _destroy: &#39;1&#39; }]
&amp;gt;   =&amp;gt; [{:id=&amp;gt;1, :_destroy=&amp;gt;&amp;quot;1&amp;quot;}]
&amp;gt; c.save
&amp;gt; c.errors
&amp;gt;   =&amp;gt; #&amp;lt;ActiveModel::Errors:0x000000038fc840 @base=#&amp;lt;Company id: 1, name: &amp;quot;Mars LLC&amp;quot;, created_at: &amp;quot;2012-10-08 19:16:44&amp;quot;, updated_at: &amp;quot;2012-10-08 19:16:44&amp;quot;&amp;gt;, @messages={:base=&amp;gt;[&amp;quot;Company should have at least one office.&amp;quot;]}&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hopefully, in Rails 3 we are now able to write our own custom validators, so I&amp;rsquo;ve added &lt;a href=&#34;http://homeonrails.com/2012/10/associationcountvalidator&#34;&gt;one more for this case&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you know a better solution, don&amp;rsquo;t hesitate to &lt;a href=&#34;http://homeonrails.com/about.html&#34;&gt;contact me&lt;/a&gt; or simply leave a comment below.&lt;/p&gt;

&lt;h3 id=&#34;validating-presence-of-the-parent-object&#34;&gt;Validating presence of the parent object&lt;/h3&gt;

&lt;p&gt;The last thing I wanna share with you is how you can add &lt;code&gt;presence&lt;/code&gt; validator
to the parent association inside the nested model.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Company::Office &amp;lt; ActiveRecord::Base
  attr_accessible :company_id, :name

  validates :name, presence: true
  # add validator to company
  validates :company, presence: true

  belongs_to :company
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We want to be sure that the office always have a corresponding company. But this fails on creating a company.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; c = Company.create(name: &#39;Adidas America Inc&#39;, offices_attributes: [{ name: &#39;LS&#39; }])
&amp;gt;   =&amp;gt; #&amp;lt;Company id: nil, name: &amp;quot;Adidas America Inc&amp;quot;, created_at: nil, updated_at: nil&amp;gt;
&amp;gt; c.errors
&amp;gt;   =&amp;gt; #&amp;lt;ActiveModel::Errors:0x000000036387a8 @base=#&amp;lt;Company id: nil, name: &amp;quot;Adidas America Inc&amp;quot;, created_at: nil, updated_at: nil&amp;gt;, @messages={:&amp;quot;offices.company&amp;quot;=&amp;gt;[&amp;quot;can&#39;t be blank&amp;quot;]}&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The solution here is to use &lt;code&gt;inverse_of&lt;/code&gt; option. See the options section
in &lt;code&gt;belongs_to&lt;/code&gt;, &lt;code&gt;has_one&lt;/code&gt; or &lt;code&gt;has_many&lt;/code&gt; &lt;a href=&#34;http://apidock.com/rails/ActiveRecord/Associations/ClassMethods/belongs_to&#34;&gt;documentation&lt;/a&gt;.
Note: it does not work in combination with the &lt;code&gt;polymorphic&lt;/code&gt; option.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Company &amp;lt; ActiveRecord::Base
  ...
  has_many :offices, inverse_of: :company
  ...
end

class Company::Office &amp;lt; ActiveRecord::Base
  ...
  belongs_to :company, inverse_of: :offices
  ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we are able to create a company instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; c = Company.create(name: &#39;Adidas America Inc&#39;, offices_attributes: [{ name: &#39;LS&#39; }])
&amp;gt;   =&amp;gt; #&amp;lt;Company id: 2, name: &amp;quot;Adidas America Inc&amp;quot;, created_at: &amp;quot;2012-10-09 07:36:07&amp;quot;, updated_at: &amp;quot;2012-10-09 07:36:07&amp;quot;&amp;gt;
&amp;gt; c.offices
&amp;gt;   =&amp;gt; #&amp;lt;Company::Office id: 6, company_id: 2, name: &amp;quot;LS&amp;quot;, created_at: &amp;quot;2012-10-09 07:36:07&amp;quot;, updated_at: &amp;quot;2012-10-09 07:36:07&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Don&#39;t do this at home on Rails #1</title>
      <link>http://homeonrails.com/2012/09/dont-do-this-at-home-on-rails-1/</link>
      <pubDate>Sun, 23 Sep 2012 00:00:00 +0000</pubDate>
      
      <guid>http://homeonrails.com/2012/09/dont-do-this-at-home-on-rails-1/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;Languages: Ruby&lt;/li&gt;
&lt;li&gt;Difficulty: &lt;span class=&#34;label label-success&#34;&gt;Easy&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;These series of articles will be dedicated to every day code, that I am working on.
This could be the parts of my own projects or some ruby gems. Together, we will try to improve quality and readability of it.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;examples&#34;&gt;Examples&lt;/h2&gt;

&lt;h3 id=&#34;1-avoid-duplication&#34;&gt;#1 - avoid duplication&lt;/h3&gt;

&lt;p&gt;The first example is a scope, that fetches the records within a given range.
If the &lt;code&gt;date&lt;/code&gt; param passed to this block responds to the &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; methods,
these are considered as start and end dates. Otherwise, it selects records for that date plus 1 day.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;scope :at_date, lambda { |date|
  if date.respond_to?(:last) &amp;amp;&amp;amp; date.respond_to?(:first)
    where(&amp;quot;created_at &amp;gt;= ? AND created_at &amp;lt;= ?&amp;quot;, date.first, date.last)
  else
    where(&amp;quot;created_at &amp;gt;= ? AND created_at &amp;lt;= ?&amp;quot;, date, date + 1.day)
  end
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What could you say about this code? Is it well written? This code has many flaws.
The first thing that caches the eye is duplicated &lt;code&gt;where&lt;/code&gt; condition.
Just imagine, each time you want to change the query, you will need to update these 2 lines.
Lets fix this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;scope :at_date, lambda { |date|
  if date.respond_to?(:last) &amp;amp;&amp;amp; date.respond_to?(:first)
    date_start = date.first
    date_end = date.last
  else
    date_start = date
    date_end = date_start + 1.day
  end

  where(&amp;quot;created_at &amp;gt;= ? AND created_at &amp;lt;= ?&amp;quot;, date_start, date_end)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Good, but that&amp;rsquo;s not all.&lt;/p&gt;

&lt;p&gt;It seems to me very confusing, that &lt;code&gt;date&lt;/code&gt; param could be
either &lt;code&gt;Array&lt;/code&gt; or &lt;code&gt;DateTime&lt;/code&gt;. Strictly speaking, it could be anything;
e.g &lt;code&gt;String&lt;/code&gt; - it&amp;rsquo;s also responds to &lt;code&gt;first/last&lt;/code&gt; methods, so as a result
we will get this query &lt;code&gt;created_at &amp;gt;= 2 and created_at &amp;lt;= 3&lt;/code&gt; for date = &amp;lsquo;2012-09-23&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;But wait, ActiveRecord&amp;rsquo;s query interface also supports ranges as an arguments,
so we could write something like this: &lt;code&gt;where(created_at: date.first..date.last)&lt;/code&gt;,
which will generate a query &lt;code&gt;created_at BETWEEN &amp;lt;date.first&amp;gt; AND &amp;lt;date.last&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;scope :at_date, lambda { |range|
  where(created_at: range)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-try-to-search-for-existing-method-first&#34;&gt;#2 - try to search for existing method first&lt;/h3&gt;

&lt;p&gt;The second slice of code selects the channels, locked by the current user and
free channels.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;cu = current_user
locked = channels.select{ |ch| ch.is_locked_by?(cu) }
free   = channels.select{ |ch| !ch.is_locked_by?(cu) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Did you notice the reverse condition? Every time I see the code,
who looks like this, I thought, it should be already a method for this in ruby.
In fact, ruby and rails has a greater collection of methods. Take a look at &lt;code&gt;ActiveSupport&lt;/code&gt;
methods &lt;a href=&#34;http://apidock.com/rails/ActiveSupport&#34;&gt;http://apidock.com/rails/ActiveSupport&lt;/a&gt;. But what about our case? After a few minutes
of searching, I&amp;rsquo;ve found &lt;code&gt;partition&lt;/code&gt; method (&lt;a href=&#34;http://apidock.com/ruby/Enumerable/partition&#34;&gt;Doc&lt;/a&gt;),
which does exactly just we want to - splits collection into two arrays by a given condition.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;locked, unlocked = channels.partition { |ch| ch.is_locked_by?(current_user) }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-think-about-what-you-are-writing-right-now&#34;&gt;#3 - think about what you are writing right now&lt;/h3&gt;

&lt;p&gt;The third method is a simple method inside some model.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def has_description?
  !self.description.blank?
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I know what you are thinking right now - it&amp;rsquo;s not my :)&lt;/p&gt;

&lt;p&gt;There are two drawbacks in the code above. The one significant is that there is already a
method for this in &lt;code&gt;ActiveRecord&lt;/code&gt;. Rails creates a method called &lt;code&gt;&amp;quot;{attribute}?&amp;quot;&lt;/code&gt;,
which checks whether a field is defined or not. So we could remove &lt;code&gt;has_description?&lt;/code&gt;
method with &lt;code&gt;description?&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note: you don&amp;rsquo;t have to use &lt;code&gt;self&lt;/code&gt; inside the model methods, because we already in the context of an object.&lt;/p&gt;

&lt;p&gt;And that&amp;rsquo;s all for today. Hope you&amp;rsquo;ve caught something for you!&lt;/p&gt;

&lt;h2 id=&#34;follow-up&#34;&gt;Follow up&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://homeonrails.com/2012/11/dont-do-this-at-home-on-rails-2&#34;&gt;Don&amp;rsquo;t do this at home on Rails #2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>