<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Erlang on Home on Rails</title>
    <link>http://homeonrails.com/tags/erlang/index.xml</link>
    <description>Recent content in Erlang on Home on Rails</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>All rights reserved - 2017</copyright>
    <atom:link href="http://homeonrails.com/tags/erlang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>The Best of Erlang User Conference 2016</title>
      <link>http://homeonrails.com/2016/10/the-best-of-erlang-user-conference-2016/</link>
      <pubDate>Thu, 20 Oct 2016 13:33:36 +0000</pubDate>
      
      <guid>http://homeonrails.com/2016/10/the-best-of-erlang-user-conference-2016/</guid>
      <description>&lt;p&gt;Videos from Erlang User Conference 2016 are up. Thank you to organizers for
sharing them with the community.&lt;/p&gt;

&lt;p&gt;As usual, I am publishing the talks, which I liked the most. Hope you&amp;rsquo;ll enjoy
these too. &lt;em&gt;Disclaimer: your experience may vary.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;1-erlang-and-deep-learning&#34;&gt;1. Erlang and Deep Learning&lt;/h1&gt;

&lt;p&gt;by Garrett Smith (47 min)&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/iMhBEVCgPdg&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;An example of a very good presentation. After watching, I immediately wanted to learn more about deep learning.&lt;/p&gt;

&lt;h1 id=&#34;2-rethinking-the-language-runtime-for-scale&#34;&gt;2. Rethinking the Language Runtime for Scale&lt;/h1&gt;

&lt;p&gt;by Christopher Meiklejohn (45 min)&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/SXT_fVJOkD0&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;Christopher continues his series of presentations about the Lasp lang and its runtime system.&lt;/p&gt;

&lt;h1 id=&#34;3-going-barking-mad-with-dalmatinerdb&#34;&gt;3. Going Barking Mad with DalmatinerDB&lt;/h1&gt;

&lt;p&gt;by Steven Acreman and Heinz Gies (42 min)&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/1lC8m3omo4I&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;h1 id=&#34;4-think-outside-the-vm-unobtrusive-performance-measurement&#34;&gt;4. Think Outside the VM: Unobtrusive Performance Measurement&lt;/h1&gt;

&lt;p&gt;by Julian Squires (44 min)&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/xP2yzaYdjpo&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;h2 id=&#34;want-more&#34;&gt;Want more?&lt;/h2&gt;

&lt;p&gt;If you are an Erlang/Elixir/LFE developer and want to help, watch &lt;a href=&#34;https://www.youtube.com/watch?v=Z28SDd9bXcE&#34;&gt;How things are, and how they could be by Fred Hebert&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Russel Brown has a &lt;a href=&#34;https://www.youtube.com/watch?v=f20882ZSdkU&#34;&gt;nice talk on CRDT in Riak&lt;/a&gt; - what they&amp;rsquo;ve already implemented and future plans.&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t know what LFE is, watch &lt;a href=&#34;https://www.youtube.com/watch?v=x2ysisqgd2g&#34;&gt;LFE: A Real Lisp in the Erlang Ecosystem by Robert Virding&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Profiling in Erlang</title>
      <link>http://homeonrails.com/2016/05/profiling-in-erlang/</link>
      <pubDate>Wed, 25 May 2016 11:41:44 +0000</pubDate>
      
      <guid>http://homeonrails.com/2016/05/profiling-in-erlang/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://homeonrails.com/pdfs/posts/2016-05-25-profiling-in-erlang/profiling_in_erlang_ru_RU.pdf&#34; title=&#34;Скачать PDF на русском&#34;&gt;
  На русском
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The list of available instruments:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;fprof, eprof, cover, cprof (shipped with erlang)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;top&lt;/code&gt;-like utilities: third party &lt;a href=&#34;https://github.com/zaa/entop&#34;&gt;entop&lt;/a&gt; и &lt;a href=&#34;http://erlang.org/doc/apps/observer/etop_ug.html&#34;&gt;etop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/virtan/eep/&#34;&gt;eep&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ferd.github.io/recon/&#34;&gt;recon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/proger/eflame&#34;&gt;eflame&lt;/a&gt; and &lt;a href=&#34;https://github.com/slfritchie/eflame&#34;&gt;eflame2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/massemanet/eper&#34;&gt;eper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timer:tc/3&lt;/code&gt;, &lt;code&gt;statistics/1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/slfritchie/159a8ce1f49fc03c77c6&#34;&gt;latency_histogram_tracer.erl&lt;/a&gt; (requires &lt;code&gt;folsom_metrics&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: here are not given the tools, which are used rarely
(&lt;a href=&#34;http://erlang.org/doc/man/percept.html&#34;&gt;percept&lt;/a&gt;), or on the basis of which
more powerful things are built (&lt;a href=&#34;http://erlang.org/doc/man/ttb.html&#34;&gt;ttb&lt;/a&gt;).&lt;/p&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;An overview of all the tools would be very time-consuming. And I doubt that
normal Erlang programmer may need all of them anyway.&lt;/p&gt;

&lt;p&gt;Far more important is to know four or five, and based on the results, obtained
during profiling, be able to find bottlenecks and decide, whenever they should
be fixed or not.&lt;/p&gt;

&lt;h2 id=&#34;fprof-cprof&#34;&gt;fprof, cprof&lt;/h2&gt;

&lt;p&gt;Like it or not, you need to know one or two standard tools.&lt;/p&gt;

&lt;p&gt;The best place to start: &lt;a href=&#34;http://erlang.org/doc/efficiency_guide/profiling.html&#34;&gt;http://erlang.org/doc/efficiency_guide/profiling.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;fprof&amp;rsquo;s output can be converted into the format suitable for kcachegrind (see
below) using the &lt;a href=&#34;https://github.com/isacssouza/erlgrind&#34;&gt;erlgrind&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;1&amp;gt; fprof:start().
2&amp;gt; fprof:trace([start, {procs, all}]). % trace all the processes (significantly slows down the system)
3&amp;gt; fprof:trace([stop]).
4&amp;gt; fprof:profile().
5&amp;gt; fprof:analyse([totals, {dest, &amp;quot;fprof.analysis&amp;quot;}]).
6&amp;gt; fprof:stop().
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can find explanations for each command above in the standard docs and also
&lt;a href=&#34;https://timanovsky.wordpress.com/2009/01/20/profiling-running-erlang-server/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;1&amp;gt; cprof:start().
2&amp;gt; cprof:pause().
3&amp;gt; cprof:analyse().
4&amp;gt; cprof:analyse(cprof). % analysing calls of a specific module
5&amp;gt; cprof:stop().
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;eep&#34;&gt;eep&lt;/h2&gt;

&lt;p&gt;The sequence of steps is quite simple and described in the project&amp;rsquo;s README.&lt;/p&gt;

&lt;p&gt;We start the tracing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;1&amp;gt; eep:start_file_tracing(&amp;quot;appname&amp;quot;), timer:sleep(10000), eep:stop_tracing().
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then copy the resulting file: &lt;code&gt;appname.trace&lt;/code&gt; to our machine (before that we
gzip it because of it&amp;rsquo;s size). On our machine, we transform it into the text
format, suitable for
&lt;a href=&#34;https://kcachegrind.github.io/html/Home.html&#34;&gt;kcachegrind&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;1&amp;gt; eep:convert_tracing(&amp;quot;appname&amp;quot;).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you still do not have kcachegrind, go install it:&lt;/p&gt;

&lt;p&gt;In Ubuntu:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install kcachegrind
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the conversion has finished, we may begin analyzing the results.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kcachegrind callgrind.out.appname
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2016-05-25-profiling-in-erlang/eep.png&#34; alt=&#34;&#34; width=&#34;100%&#34; title=&#34;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;3 important points:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;group by &amp;ldquo;Source File&amp;rdquo; (or by &amp;ldquo;ELF Object&amp;rdquo; if you target is a particular PID);&lt;/li&gt;
&lt;li&gt;percentage (&amp;ldquo;Relative&amp;rdquo;) is better than absolute time;&lt;/li&gt;
&lt;li&gt;percentage relative to its parent (&amp;ldquo;Relative to Parent&amp;rdquo;) is even better, otherwise, you can&amp;rsquo;t understand the damn thing.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;ldquo;No Grouping&amp;rdquo; and &amp;ldquo;Function Cycle&amp;rdquo; do not give a clear picture of what is
happening. The first option leads to the top lines: &lt;code&gt;gen_server:decode_msg&lt;/code&gt;,&lt;code&gt;
gen_server:loop&lt;/code&gt;, and only indicates that more time spent in &lt;code&gt;gen_server:*&lt;/code&gt; -
thank you, captain! I didn&amp;rsquo;t understand the results of the second option.&lt;/p&gt;

&lt;h2 id=&#34;eflame2&#34;&gt;eflame2&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;1&amp;gt; eflame2:write_trace(global_calls_plus_new_procs, &amp;quot;/tmp/ef.test.0&amp;quot;, all, 10*1000).
2&amp;gt; eflame2:format_trace(&amp;quot;/tmp/ef.test.0&amp;quot;, &amp;quot;/tmp/ef.test.0.out&amp;quot;).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;According to the docs, we need to run tracing in a separate process. But when
I&amp;rsquo;d tried to do so, I got &amp;ldquo;Segmentation fault&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /tmp/ef.test.0.out | ./flamegraph.riak-color.pl &amp;gt; output.svg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2016-05-25-profiling-in-erlang/eflame2.png&#34; alt=&#34;&#34; width=&#34;100%&#34; title=&#34;&#34;/&gt;&lt;/p&gt;

&lt;h2 id=&#34;timer-tc&#34;&gt;timer:tc&lt;/h2&gt;

&lt;p&gt;What is there to talk? Recently, I came across an unexpected behavior. Take a
look at the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;{Time, Result} = timer:tc(fun() -&amp;gt;
    {Time1, Result1} = timer_tc(fun() -&amp;gt; do_smth1() end)
    {Time2, Result2} = timer_tc(fun() -&amp;gt; do_smth2() end)
end)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Time&lt;/code&gt; should be equal to &lt;code&gt;Time1 + Time2&lt;/code&gt;, right?&lt;/p&gt;

&lt;p&gt;Well, not in reality. &lt;strong&gt;Time is often greater than Time1 + Time2&lt;/strong&gt; (even if I
measure it, say 100 times). I think it is because &lt;code&gt;timer:tc&lt;/code&gt; uses&lt;code&gt;
os:timestamp&lt;/code&gt; and &lt;code&gt;Time&lt;/code&gt; includes some switching (when scheduler runs other
process).&lt;/p&gt;

&lt;p&gt;Useful links:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.snookles.com/erlang/ef2015/slf-presentation.html&#34;&gt;Actively measuring and profiling Erlang code by S. L. Fritchie&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://roberto-aloi.com/erlang/profiling-erlang-applications-using-redbug/&#34;&gt;Profiling Erlang Apps using Redbug (using eper)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Как стартовать Erlang приложение</title>
      <link>http://homeonrails.com/2016/04/how-do-i-start-erlang-application/</link>
      <pubDate>Mon, 25 Apr 2016 10:38:13 +0000</pubDate>
      
      <guid>http://homeonrails.com/2016/04/how-do-i-start-erlang-application/</guid>
      <description>&lt;p&gt;Подразумевается, что у вас уже есть какое-то приложение и вы используете 3й
rebar.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Disclaimer: этот способ, который принят у меня в компании и которого
придерживаюсь я. Он не претендует на звание &amp;ldquo;единственно правильный способ&amp;rdquo;.
Если вы видите явные недочеты, пишите в комментариях.&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;как-запускаем-приложение-при-разработке&#34;&gt;Как запускаем приложение при разработке&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-makefile&#34;&gt;# Makefile

.PHONY: all compile run

REBAR=./rebar3

all: compile

compile:
    $(REBAR) compile

run: compile
		erl -pa _build/default/lib/*/ebin -config config/sys.config -args_file config/vm.args -boot start_sasl -s sync -s yourawesomeapp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sasl нужен для более красивых и подробных сообщениях об ошибках и не только:
запуск, перезапуск, падение частей приложения.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/rustyio/sync&#34;&gt;https://github.com/rustyio/sync&lt;/a&gt; перекомпилирует и перезагружает код налету.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-s yourawesomeapp&lt;/code&gt; попытается вызвать &lt;code&gt;yourawesomeapp:start()&lt;/code&gt;, так что нужен файл следующего содержания (если у вас его еще нет):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;-module(yourawesomeapp).

-export([start/0]).

-spec start() -&amp;gt; &#39;ok&#39;.
start() -&amp;gt;
    {ok, _} = application:ensure_all_started(yourawesomeapp),
    ok.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ensure_all_started удостоверится, что все зависимости вашего приложения запущены.&lt;/p&gt;

&lt;p&gt;Плохой практикой считается старт зависимостей вручную:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% ПЛОХО
% yourawesomeapp_app.erl

-spec start(any(), any()) -&amp;gt; no_return().
start(_StartType, _StartArgs) -&amp;gt;
    lager:start(),
    yourawesomeapp_sup:start_link().

% ХОРОШО
% yourawesomeapp.app.src

{application, yourawesomeapp,
 [
  {description, &amp;quot;Dope app #1&amp;quot;},
  ...
  {applications, [
                  kernel,
                  stdlib,

                  lager
                 ]},
  ...
 ]}.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;% config/sys.config

[
    {yourawesomeapp, [
    ]},

    %% SASL config
    {sasl, [
        {sasl_error_logger, {file, &amp;quot;log/sasl-error.log&amp;quot;}},
        {errlog_type, error},
        {error_logger_mf_dir, &amp;quot;log/sasl&amp;quot;},
        {error_logger_mf_maxbytes, 10485760},
        {error_logger_mf_maxfiles, 5}
    ]}
].
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;% config/vm.args

## Name of the node
-sname yourawesomeapp

## Cookie for distributed erlang
-setcookie XXX

## Heartbeat management; auto-restarts VM if it dies or becomes unresponsive
## (Disabled by default..use with caution!)
##-heart

## Enable kernel poll and a few async threads
+K true
+A 10

## Distribution buffer busy limit (dist_buf_busy_limit)
+zdbbl 8192

## Sets mapping for warning messages
+W w

## Sets  the number of scheduler threads to create and scheduler
## threads to set online when SMP support has been enabled.
#+S 2:2

## Increase number of concurrent ports/sockets
##-env ERL_MAX_PORTS 4096

## Tweak GC to run more often
##-env ERL_FULLSWEEP_AFTER 10

## Application libraries
##-env ERL_LIBS /srv/projects/yourawesomeapp

## Increase the maximum number of simultaneously existing processes
+P 1048576
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;как-запускаем-приложение-в-продакшене&#34;&gt;Как запускаем приложение в продакшене&lt;/h1&gt;

&lt;p&gt;Тут все зависит от того, релизы у вас или нет. Если релизы, при сборке вы просто указываете нужные vm.args и sys.config:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{relx, [
    {release, {yourawesomeapp, &amp;quot;1.0.0&amp;quot;},
     %% list of apps to include
     [yourawesomeapp, sasl, lager]},

    %% Don&#39;t ship an Erlang VM by default
    {include_erts, false},

    {vm_args, &amp;quot;./config/vm.args&amp;quot;}
]}.

{profiles, [
    %% called as `rebar3 as prod &amp;lt;command&amp;gt;`
    {prod, [
        {relx, [ % override relx specifically
          {include_src, false}, % don&#39;t include source code
          {include_erts, true},  % include the VM in the release

          {sys_config, &amp;quot;./config/production.config&amp;quot;}
        ]}
    ]}
]}.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Если нет, можно указать vm.args и sys.config посредством ключей к &lt;code&gt;erl&lt;/code&gt; (см.
make run) или использовать переменные окружения: ARGS_FILE и CONFIG_FILE.&lt;/p&gt;

&lt;p&gt;Полезные ссылки:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://howistart.org/posts/erlang/1&#34;&gt;Короткий туториал от настройки среды до создания релиза&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/juise/myapp&#34;&gt;Описание разных способов создать релиз&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Chokecherry Or The Story About 1000000 Timeouts</title>
      <link>http://homeonrails.com/2016/04/chokecherry/</link>
      <pubDate>Sun, 24 Apr 2016 11:25:45 +0000</pubDate>
      
      <guid>http://homeonrails.com/2016/04/chokecherry/</guid>
      <description>&lt;p&gt;Chokecherry (&lt;a href=&#34;https://github.com/funbox/chokecherry&#34;&gt;https://github.com/funbox/chokecherry&lt;/a&gt;) is a wrapper around lager
logger which limits the volume of info messages irrespectively of the lager&amp;rsquo;s
backend.&lt;/p&gt;

&lt;p&gt;This article tells a story behind this library. Down below you&amp;rsquo;ll find answers to the following questions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Why it was created?&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;How it works?&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Do I need it?&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-story-about-1000000-timeouts&#34;&gt;The Story About 1000000 Timeouts&lt;/h2&gt;

&lt;p&gt;We use lager in almost all of our applications. And it works pretty well most
of the time, except the cases where it doesn&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2016-04-24-chokecherry/karate.gif&#34; alt=&#34;&#34; width=&#34;100%&#34; title=&#34;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;It all started one day when we were experiencing a &lt;strong&gt;peak load&lt;/strong&gt; in one of the
applications (we&amp;rsquo;ll call it FortKnox). So, FortKnox was processing a lot of
data and producing a lot of logs (particularly, info messages). As
shown on a picture below, we were writing logs to a file on disk.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2016-04-24-chokecherry/app1.png&#34; alt=&#34;&#34; width=&#34;100%&#34; title=&#34;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Then we started seeing &lt;strong&gt;random exits&lt;/strong&gt; (timeouts in calls to &lt;code&gt;lager:info&lt;/code&gt;)
from many places. These led to different parts (gen_servers, gen_fsms, etc.) of
FortKnox crashing. Some of them got restarted by their supervisor. But it was
clear that this won&amp;rsquo;t last long. Indeed, at some point, it all came down to the
application&amp;rsquo;s supervisor and &lt;strong&gt;whole node stopped working&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2016-04-24-chokecherry/app2.png&#34; alt=&#34;&#34; width=&#34;100%&#34; title=&#34;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;This is what happened. &lt;strong&gt;Hard disk was not able to handle so much writes&lt;/strong&gt; (even in
the presence of OS caches). &lt;a href=&#34;https://github.com/basho/lager/blob/ec43800bd5bf0286c5d591fbda0b2d22fccf4d7b/src/lager_file_backend.erl#L257&#34;&gt;file:write&lt;/a&gt; became slower and lager&amp;rsquo;s
message box started to grow in size. The behavior for lager, in that case, is
to switch to synchronous mode (see
&lt;a href=&#34;https://github.com/basho/lager#overload-protection&#34;&gt;https://github.com/basho/lager#overload-protection&lt;/a&gt; for details), what he did.
That&amp;rsquo;s how we came to the random exits.&lt;/p&gt;

&lt;p&gt;Possible solutions were (&lt;a href=&#34;https://groups.google.com/forum/#!topic/erlang-russian/8xEeffAV8sc&#34;&gt;discussion on erlang-russian&lt;/a&gt;):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;del&gt;RAM disk&lt;/del&gt; (high cost of maintenance)&lt;/li&gt;
&lt;li&gt;&lt;del&gt;configure lager in such a way, that would fix the problem&lt;/del&gt; (no way to do that)&lt;/li&gt;
&lt;li&gt;&lt;del&gt;use tmpfs for &lt;code&gt;/tmp&lt;/code&gt;&lt;/del&gt; (low cost of maintenance; difficult to setup syncing tmpfs to disk; some logs still could be lost)&lt;/li&gt;
&lt;li&gt;create a thin wrapper around lager (low cost of maintenance; easy to setup; some logs may be dropped)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;on-lager-settings&#34;&gt;On lager settings&lt;/h3&gt;

&lt;p&gt;lager has many settings and we could play with them. For example, we could turn
off synchronous mode.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2016-04-24-chokecherry/app3.png&#34; alt=&#34;&#34; width=&#34;100%&#34; title=&#34;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;What will happen then is lager&amp;rsquo;s mailbox start growing and, eventually, when
there will be no more free memory, node will crash.&lt;/p&gt;

&lt;p&gt;{% blockquote %}
For performance, the file backend does delayed writes, although it will sync at
specific log levels, configured via the `sync_on&amp;rsquo; option. By default the error
level or above will trigger a sync.
{% endblockquote %}&lt;/p&gt;

&lt;p&gt;Keep in mind that there were an exessive amount of info messages, so no &lt;code&gt;fsync&lt;/code&gt;
calls (&lt;a href=&#34;https://github.com/basho/lager/blob/1159f9262fb589ce2ec310eb7dec5ac03b1fee16/src/lager_file_backend.erl#L262&#34;&gt;file:datasync&lt;/a&gt;) were made (we didn&amp;rsquo;t change the default).&lt;/p&gt;

&lt;p&gt;So &lt;strong&gt;there was no simple solution&lt;/strong&gt; for this problem. &lt;strong&gt;That&amp;rsquo;s why we created
chokecherry&lt;/strong&gt;. What follows is how it works.&lt;/p&gt;

&lt;h2 id=&#34;chokecherry&#34;&gt;Chokecherry&lt;/h2&gt;

&lt;p&gt;&lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2016-04-24-chokecherry/app4.png&#34; alt=&#34;&#34; width=&#34;100%&#34; title=&#34;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;shaper&lt;/strong&gt; accumulates incoming messages in the queue. If the queue size
exceeds &lt;code&gt;log_queue_capacity&lt;/code&gt; within a certain time period (1 second), it sends
an error_report &amp;ldquo;chokecherry dropped N messages in the last second&amp;rdquo;, and drops
messages from the end of the queue, while receiving new ones and maintaining
the maximum size of the queue.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;writer&lt;/strong&gt; pulls messages from &lt;strong&gt;shaper&lt;/strong&gt; and transmits them to lager.&lt;/p&gt;

&lt;p&gt;Default settings are as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
    {chokecherry, [
        {shaper, [
            {timeout, 1000},
            {log_queue_capacity, 10000}
        ]}
    ]}
].
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;do-you-need-it&#34;&gt;Do you need it&lt;/h2&gt;

&lt;p&gt;If your application produces a lot of logs and you can afford to lose some
(i.e. stable work of an application is more important to you) - &lt;strong&gt;yes&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;In the above story, we were writing logs to a file using &lt;code&gt;lager_file_backend&lt;/code&gt;.
This doesn&amp;rsquo;t mean that a similar story could not happen to you if you&amp;rsquo;re using
a different backend. So it may be applicable to other backends likewise.&lt;/p&gt;

&lt;h2 id=&#34;source-code&#34;&gt;Source code&lt;/h2&gt;

&lt;p&gt;Currently, we are only &amp;ldquo;shaping&amp;rdquo; info messages. If you think we should do it
for warning and error, or make it optional, let us know.&lt;/p&gt;

&lt;p&gt;Source code: &lt;a href=&#34;https://github.com/funbox/chokecherry&#34;&gt;https://github.com/funbox/chokecherry&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Зависла Erlang нода. Что делать?</title>
      <link>http://homeonrails.com/2016/04/erlang-node-freezes-now-what/</link>
      <pubDate>Tue, 05 Apr 2016 15:50:31 +0000</pubDate>
      
      <guid>http://homeonrails.com/2016/04/erlang-node-freezes-now-what/</guid>
      <description>&lt;p&gt;&lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2016-04-05-erlang-node-freezes-now-what/debug_mode_on.jpg&#34; alt=&#34;&#34; width=&#34;100%&#34; title=&#34;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Пишу статью по горячим следам. Пару дней назад тестировал работу приложения при
пропаже соединения с Redis&amp;rsquo;ом. Так вот, после возобновления соединения
(успешном переподключении), через раз приложение зависало полностью. Ни
консолью подрубиться, ничего&amp;hellip;&lt;/p&gt;

&lt;p&gt;Обычно такое происходит, если вы используете C-расширение, оформленное в виде
NIF, и оно в один прекрасный момент блокируется. Шедулер Erlang в таком случае
не может прервать выполнение потока, как он поступил бы в случае с Erlang
кодом.&lt;/p&gt;

&lt;p&gt;Всякие Linux утилиты (типа &lt;code&gt;strace&lt;/code&gt;) нам мало о чем скажут. Как дебажить
C-расширения в Erlang тоже непонятно (отдельно - понятно, &lt;code&gt;gdb&lt;/code&gt; и тому
подобное). Если знаете - напишите плиз.&lt;/p&gt;

&lt;p&gt;Зато мы можем послать сигнал виртуальной машине Erlang и она создаст crash dump:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kill -SIGUSR1 &amp;lt;pid&amp;gt;

Crash dump is being written to: erl_crash.dump...done
Received SIGUSR1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Смотреть на него без дополнительных утилит еще более болезненно, чем на вывод
&lt;code&gt;tcpdump&lt;/code&gt; без &lt;a href=&#34;https://www.wireshark.org/&#34;&gt;Wireshark&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;анализируем-crashdump&#34;&gt;Анализируем crashdump&lt;/h2&gt;

&lt;p&gt;Мне известны по крайней мере 2 инструмента: crashdump_viewer и recon.&lt;/p&gt;

&lt;h3 id=&#34;crashdump-viewer&#34;&gt;crashdump_viewer&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://erlang.org/doc/apps/observer/crashdump_ug.html&#34;&gt;http://erlang.org/doc/apps/observer/crashdump_ug.html&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ erl
&amp;gt; crashdump_viewer:start().
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2016-04-05-erlang-node-freezes-now-what/crashdump_ug1.png&#34; alt=&#34;&#34; width=&#34;100%&#34; title=&#34;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Общая информация.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2016-04-05-erlang-node-freezes-now-what/crashdump_ug2.png&#34; alt=&#34;&#34; width=&#34;100%&#34; title=&#34;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Список процессов.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2016-04-05-erlang-node-freezes-now-what/crashdump_ug3.png&#34; alt=&#34;&#34; width=&#34;100%&#34; title=&#34;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Информация по одному из немногих запущенных процессов с большим количеством
редукций. Чтобы найти конкретный процесс, внутри которого произошла блокировка,
пришлось просмотреть несколько штук (количество запущенных процессов обычно =
числу ядер).&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2016-04-05-erlang-node-freezes-now-what/crashdump_ug4.png&#34; alt=&#34;&#34; width=&#34;100%&#34; title=&#34;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;stackdump процесса.&lt;/p&gt;

&lt;p&gt;Как видно из 2-й картинки выше мы заблокировались на
&lt;code&gt;hierdis:pipeline_cleaner/4&lt;/code&gt; (см. &amp;ldquo;Continuation pointer&amp;rdquo;).
&lt;a href=&#34;https://github.com/funbox/hierdis&#34;&gt;Hierdis&lt;/a&gt; - это клиент для Redis, который мы
используем. Далее оставалось делом техники воспроизвести вызов (подсмотреть
аргументы можно либо в crashdump_viewer, либо используя
&lt;a href=&#34;https://ferd.github.io/recon/recon_trace.html&#34;&gt;recon_trace&lt;/a&gt;) в самом клиенте и
найти конкретную причину (&lt;a href=&#34;https://github.com/funbox/hierdis/pull/1&#34;&gt;PR&lt;/a&gt;).&lt;/p&gt;

&lt;h3 id=&#34;recon&#34;&gt;recon&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://ferd.github.io/recon/&#34;&gt;https://ferd.github.io/recon/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./recon/scripts/erl_crashdump_analyzer.sh &amp;lt;crashdump&amp;gt;

analyzing erl_crash.dump, generated on:  Tue Apr 5 12:30:26 2016

Slogan: Received SIGUSR1

Memory:
===
  processes: 374 Mb
  processes_used: 374 Mb
  system: 14 Mb
  atom: 0 Mb
  atom_used: 0 Mb
  binary: 0 Mb
  code: 8 Mb
  ets: 0 Mb
  ---
  total: 388 Mb

Different message queue lengths (5 largest different):
===
      3 1
    217 0

Error logger queue length:
===
0

File descriptors open:
===
  UDP:  2
  TCP:  8
  Files:  4
  ---
  Total:  14

Number of processes:
===
220

Processes Heap+Stack memory sizes (words) used in the VM (5 largest different):
===
      1 10695351
      2 8912793
      1 3581853
      1 2487399
      2 2072833

Processes OldHeap memory sizes (words) used in the VM (5 largest different):
===
      1 7427328
      1 514838
      1 121536
      2 28690
      1 10958

Process States when crashing (sum):
===
      4 Current Process Internal ACT_PRIO_NORMAL | USR_PRIO_NORMAL | PRQ_PRIO_NORMAL | ACTIVE | RUNNING
      4 Current Process Running
      3 Internal ACT_PRIO_MAX | USR_PRIO_MAX | PRQ_PRIO_MAX
      2 Internal ACT_PRIO_MAX | USR_PRIO_MAX | PRQ_PRIO_MAX | TRAP_EXIT
     90 Internal ACT_PRIO_NORMAL | USR_PRIO_NORMAL | PRQ_PRIO_NORMAL
      4 Internal ACT_PRIO_NORMAL | USR_PRIO_NORMAL | PRQ_PRIO_NORMAL | ACTIVE | RUNNING
      3 Internal ACT_PRIO_NORMAL | USR_PRIO_NORMAL | PRQ_PRIO_NORMAL | IN_PRQ_NORMAL | ACTIVE | IN_RUNQ
    118 Internal ACT_PRIO_NORMAL | USR_PRIO_NORMAL | PRQ_PRIO_NORMAL | TRAP_EXIT
      4 Running
      3 Scheduled
    213 Waiting
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Он дает общую картину того, что происходит.&lt;/p&gt;

&lt;p&gt;Вообще recon довольно полезная библиотека. В ней можно найти различные модули
для инспекции состояния ноды, трассировки и т.д.&lt;/p&gt;

&lt;p&gt;Вот например скрипт, который показывает работающие (running) процессы с
количеством сообщений в mailbox&amp;rsquo;е &amp;gt;= &lt;code&gt;threshold&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ awk -v threshold=1 -f ./recon/script/queue_fun.awk erl_crash.dump                                                                                                                                         MESSAGE QUEUE LENGTH: CURRENT FUNCTION
======================================
1: gen_server:loop/6
1: gen:do_call/4
1: gen:do_call/4
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>The Best of Erlang Factory SF Bay 2016</title>
      <link>http://homeonrails.com/2016/03/the-best-of-erlang-factory-sf-bay-2016/</link>
      <pubDate>Thu, 31 Mar 2016 10:49:23 +0000</pubDate>
      
      <guid>http://homeonrails.com/2016/03/the-best-of-erlang-factory-sf-bay-2016/</guid>
      <description>&lt;p&gt;Annual &lt;a href=&#34;http://www.erlang-factory.com/sfbay2016&#34;&gt;Erlang Factory SF Bay Area
2016&lt;/a&gt; conference ended only 3 weeks
ago. There were many great speakers and presentations. What I specifically like
about it, is that videos are available almost immediately. As usual, I am
publishing the talks, which I liked the most. Hope you&amp;rsquo;ll enjoy these too.
&lt;em&gt;Disclaimer: your experience may vary.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;1-jamshid-mahdavi-an-erlang-based-philosophy-for-service-reliability-1&#34;&gt;1. Jamshid Mahdavi - An Erlang based Philosophy for Service Reliability 1&lt;/h1&gt;

&lt;p&gt;by Jamshid Mahdavi, WhatsApp Inc. (45 min)&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/tW49z8HqsNw&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;Great talk from the WhatsApp engineer on how they make this app so bulletproof.&lt;/p&gt;

&lt;h1 id=&#34;2-a-brief-history-of-time&#34;&gt;2. A Brief History of Time&lt;/h1&gt;

&lt;p&gt;by Fred Hebert aka ferd (45 min)&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/WoUn2XQvGDw&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;An excursion into the history of different civilizations and their calendars. Fascinating!&lt;/p&gt;

&lt;h1 id=&#34;3-reactive-programming-with-elixir-and-rethinkdb&#34;&gt;3. Reactive Programming With Elixir And RethinkDB&lt;/h1&gt;

&lt;p&gt;by Peter Hamilton, RethinkDB (36 min)&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/6K0Tjvn6PV8&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;Peter talks about one of the ways to build a reliable processing pipeline which
stores intermediate results inside RethinkDB. You will need something like this
if it&amp;rsquo;s undesirable to restart the whole pipeline from the beginning.&lt;/p&gt;

&lt;h1 id=&#34;4-keynote-phoenix-and-elm-making-the-web-functional&#34;&gt;4. Keynote Phoenix and Elm – Making the Web Functional&lt;/h1&gt;

&lt;p&gt;by Chris McCord and Evan Czaplicki (55 min)&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/XJ9ckqCMiKk&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;Feel free to skip the Elm part if you are already familiar with this language.&lt;/p&gt;

&lt;h1 id=&#34;5-high-performance-erlang-pitfalls-and-solutions&#34;&gt;5. High Performance Erlang Pitfalls and Solutions&lt;/h1&gt;

&lt;p&gt;by MZSPEED team, MachineZone Inc. (47 min)&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/SPZV2h_r4U0&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;How would you build a fast data processing system in Erlang? The presenters
tell a story about their attempts in building one and the difficulties they
faced along the way.&lt;/p&gt;

&lt;p&gt;Also there were 2 talks on &lt;a href=&#34;https://nixos.org/&#34;&gt;NixOS&lt;/a&gt;, which seems interesting.&lt;/p&gt;

&lt;p&gt;If are planning to use Kafka with Erlang, you should probably watch &lt;a href=&#34;https://youtu.be/FTLTbB8BlYc&#34;&gt;this talk&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Не верь своему тимлиду</title>
      <link>http://homeonrails.com/2015/10/dont-trust-your-devlead/</link>
      <pubDate>Thu, 22 Oct 2015 10:16:35 +0000</pubDate>
      
      <guid>http://homeonrails.com/2015/10/dont-trust-your-devlead/</guid>
      <description>&lt;p&gt;&amp;ldquo;Не верь своему тимлиду&amp;rdquo; или когда не стоит слепо верить словам вашего тимлида.&lt;/p&gt;

&lt;div style=&#34;align:center&#34;&gt;
  &lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2015-10-22-dont-trust-your-devlead/dog.png&#34; alt=&#34;&#34; width=&#34;100%&#34; title=&#34;&#34;/&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Большинство моих читателей находится в подчинении у тимлида или VP of
Engineering, словом у человека, умудренного опытом или, по крайней мере,
знающего побольше своих подчиненных. И это нормально. И ты доверяешь опыту
данного человека, но бывают случаи, когда стоит все же проверить прав он или
нет.&lt;/p&gt;

&lt;p&gt;Так вот, приключился давеча со мной забавный случай. В одном из пулл-реквестов
VP of Engineering мне написал: &amp;ldquo;Тут можно сильно разогнать, используя в
качестве аккумулятора dict и обновляя значения через dict:update.&amp;ldquo;.&lt;/p&gt;

&lt;p&gt;А вот и код, о котором идет речь:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;% for every Item in Items, коих около 5000
NewAcc = case gb_sets:is_member(RangeStart, RangeStarts) of
  false -&amp;gt;
    case lists:keyfind(norange, 1, Acc) of
      {norange, List} -&amp;gt; [{norange, [Item|List]}|lists:keydelete(norange, 1, Acc)];
      false -&amp;gt; [{norange, [Item]}|Acc]
    end;
  true -&amp;gt;
    case lists:keyfind(RangeStart, 1, Acc) of
      {RangeStart, List} -&amp;gt; [{RangeStart, [Item|List]}|lists:keydelete(RangeStart, 1, Acc)];
      false -&amp;gt; [{RangeStart, [Item]}|Acc]
    end
end,
...
% позже возвращаем результирующий список
NewAcc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Обратите внимание, что элементы range хранятся в списках и все операции (за
исключением поиска в сбалансированном дереве) производятся над списками.&lt;/p&gt;

&lt;p&gt;Я решил проверить, действительно ли использование dict способно повысить
производительность данного кода (т.е. сократить время выполнения). Для начала
замерил скорость работы со списками:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Range: 398 - 7667 mics
Median: 1798 mics
Average: 1846 mics
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Потом попробовал &lt;code&gt;dict:append_list&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;% for every Item in Items, коих около 5000
NewAcc = case gb_sets:is_member(RangeStart, RangeStarts) of
  false -&amp;gt;
    case dict:is_key(norange, Acc) of
      false -&amp;gt; dict:append(norange, Item, Acc);
      true -&amp;gt; dict:append_list(norange, [Item], Acc)
    end;
  true -&amp;gt;
    case dict:is_key(RangeStart, Acc) of
      false -&amp;gt; dict:append(RangeStart, Item, Acc);
      true -&amp;gt; dict:append_list(RangeStart, [Item], Acc)
    end
end,
...
% позже возвращаем результирующий список
dict:to_list(NewAcc)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Range: 61466 - 94095 mics
Median: 67062 mics
Average: 68343 mics
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Он оказался значительно медленнее (из-за того, что списки склеиваются с помощью &lt;code&gt;++&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Затем попробовал &lt;code&gt;dict:update&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;% for every Item in Items, коих около 5000
Key = case gb_sets:is_member(RangeStart, RangeStarts) of
  false -&amp;gt; norange;
  true -&amp;gt; RangeStart
end,
NewAcc = dict:update(Key, fun(List) -&amp;gt; [Item|List] end, [Item], Acc),
...
% позже возвращаем результирующий список
dict:to_list(NewAcc)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Range: 4044 - 11357 mics
Median: 4672 mics
Average: 4963 mics
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Кода меньше в разы, но по скорости уступает, а на данном участке нам важна была
именно скорость.&lt;/p&gt;

&lt;p&gt;&lt;div style=&#34;align:center&#34;&gt;
  &lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2015-10-22-dont-trust-your-devlead/avgs.png&#34; alt=&#34;&#34; width=&#34;100%&#34; title=&#34;&#34;/&gt;
&lt;/div&gt;
(&lt;em&gt;создал диаграмму с помощью R&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Конкретные цифры не так важны, ибо они зависят от множества факторов, включая
размер входящего списка Items, количества RangeStart&amp;rsquo;ов, машинку, на которой
это все запускается, версию Erlang и т.п.&lt;/p&gt;

&lt;p&gt;Что важно, так это то, что профессионал своего дела должен уметь распознать
таковые моменты, когда стоит проверить указания или советы вашего тимлида. Я не
думаю, что есть конкретные условия или признаки, которые подскажут вам
необходимость проверки. Скорее знание структур данных используемого вами языка
и механизма работы VM и ОС помогут вам научиться распознавать такие случаи. Так
что читайте книги и помните правило - &amp;ldquo;доверяй, но проверяй&amp;rdquo;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>The best of Erlang User Conference 2015</title>
      <link>http://homeonrails.com/2015/08/the-best-of-erlang-user-conference-2015/</link>
      <pubDate>Mon, 10 Aug 2015 11:53:19 +0000</pubDate>
      
      <guid>http://homeonrails.com/2015/08/the-best-of-erlang-user-conference-2015/</guid>
      <description>&lt;p&gt;It’s been a few months since this year’s Erlang User Conference 2015, so most
of the videos are now online (kudos to organizers). Here is a short list of my
favorite talks. Enjoy!&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;1-about-language-design&#34;&gt;1. About Language Design&lt;/h1&gt;

&lt;p&gt;by Robert Virding (&lt;strong&gt;44 min&lt;/strong&gt;)&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/afLRmoSOnHA&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;h1 id=&#34;2-techniques-for-metaprogramming-in-erlang&#34;&gt;2. Techniques for Metaprogramming in Erlang&lt;/h1&gt;

&lt;p&gt;by Sean Cribbs (&lt;strong&gt;40 min&lt;/strong&gt;)&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/8v4ZfJUTnLc&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;h1 id=&#34;3-cloud-scale-erlang&#34;&gt;3. Cloud Scale Erlang&lt;/h1&gt;

&lt;p&gt;by Richard Croucher (&lt;strong&gt;38 min&lt;/strong&gt;)&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/te89NpsryTA&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;h1 id=&#34;4-building-a-scalable-real-time-bidding-exchange&#34;&gt;4. Building a Scalable Real Time Bidding Exchange&lt;/h1&gt;

&lt;p&gt;by Philip Clarke (&lt;strong&gt;37 min&lt;/strong&gt;)&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/4PDInGV7bNw&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;</description>
    </item>
    
    <item>
      <title>From Ruby To Erlang. Beginner&#39;s mistakes</title>
      <link>http://homeonrails.com/2015/08/from-ruby-to-erlang/</link>
      <pubDate>Mon, 03 Aug 2015 15:09:10 +0000</pubDate>
      
      <guid>http://homeonrails.com/2015/08/from-ruby-to-erlang/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve  been programming full-time using Erlang for a while already (about eight
months or so). Before Erlang, I was doing some hardcore Ruby. Obviously, these
are very different languages: OOP vs functional, mutable vs immutable and so
on. Also, there are things you won&amp;rsquo;t find in Ruby (the opposite is also true).&lt;/p&gt;

&lt;p&gt;In this post I want to show you the mistakes that I&amp;rsquo;ve made and the lessons
that I&amp;rsquo;ve learned during the transition.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-list-comprehensions&#34;&gt;1. List Comprehensions&lt;/h2&gt;

&lt;p&gt;There is no such thing as List Comprehension in Ruby (but you could write
&lt;a href=&#34;http://blog.tarkalabs.com/2015/04/21/list-comprehension-in-ruby/&#34;&gt;something similar&lt;/a&gt;), so when I was using it in Erlang, I didn&amp;rsquo;t fully
understand how it works. Let me show you.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;[X || X &amp;lt;- [1,2,3,4,5,6], X &amp;gt; 3].
=&amp;gt; [4,5,6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are 3 main components here:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;X &amp;lt;- [1,2,3,4,5,6]&lt;/code&gt; - &lt;strong&gt;generator&lt;/strong&gt; - usually some set of elements;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;X &amp;gt; 3&lt;/code&gt; - &lt;strong&gt;filter&lt;/strong&gt; - conditions, that we impose on these elements;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;X&lt;/code&gt; - &lt;strong&gt;list&lt;/strong&gt; - expression, which gives us the resulting element.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2015-08-03-from-ruby-to-erlang/listc1.png&#34; alt=&#34;&#34;/ width=&#34;100%&#34; title=&#34;&#34;&gt;&lt;/p&gt;

&lt;p&gt;I thought that, the way it works is &amp;ldquo;one by one&amp;rdquo;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;element is taken from generator;&lt;/li&gt;
&lt;li&gt;if it passes all the filters, the expression on the left gets executed;
otherwise, goto (1).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As it turned out, I was wrong. I&amp;rsquo;ve noticed it, when I wrote a for loop using
list comprehension, and, later on, one of the filters fell.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;[save(Rec, Db) || Rec &amp;lt;- Records, is_dirty(Rec), can_be_saved(Rec)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;this is not the production code&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;What do you think will happen if &lt;code&gt;can_be_saved&lt;/code&gt; throw an error for the
third record? &lt;strong&gt;Correct answer&lt;/strong&gt;: non of the records will be saved.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2015-08-03-from-ruby-to-erlang/listc2.png&#34; alt=&#34;&#34;/ width=&#34;100%&#34; title=&#34;&#34;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2015-08-03-from-ruby-to-erlang/listc3.png&#34; alt=&#34;&#34;/ width=&#34;100%&#34; title=&#34;&#34;&gt;&lt;/p&gt;

&lt;p&gt;The way it works is &amp;ldquo;one by one || one by one&amp;rdquo;: firstly, Erlang generates and
filters initial list. After that, it executes expression on the left side for
each item resulting in a new list.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lesson #1. List Comprehension should not be used when you need a for loop. Instead, use recursion.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;save_records([], _) -&amp;gt; ok;
save_records([Rec|Rest], Db) -&amp;gt;
    try
        case is_dirty(Rec) of
            false -&amp;gt; throw({filtered, io_lib:format(&amp;quot;~p not dirty&amp;quot;, [Rec])});
            true -&amp;gt; ok
        end,
        case can_be_saved(Rec) of
            false -&amp;gt; throw({filtered, io_lib:format(&amp;quot;~p cannot be saved&amp;quot;, [Rec])});
            true -&amp;gt; ok
        end
    of _ -&amp;gt;
        save(Rec, Db)
    catch
        throw:{filtered, Reason} -&amp;gt; lager:debug(Reason)
    end,
    save_records(Rest, Db).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This way, if &lt;code&gt;can_be_saved&lt;/code&gt; does throw an error, at least some of the records
will be saved.&lt;/p&gt;

&lt;h2 id=&#34;2-lager&#34;&gt;2. Lager&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/basho/lager&#34;&gt;lager&lt;/a&gt; is a logging framework for Erlang and
it has become a de facto standard for Erlang applications.&lt;/p&gt;

&lt;p&gt;Usually, when you look through log files in Ruby (e.g. puma.log), you can say
&amp;ldquo;we started processing at XXX and finished at YYY&amp;rdquo; and it will be more or less
accurate.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;I, [2015-04-31T03:04:20.613116 #28143]  INFO -- : Started
...
I, [2015-04-31T03:04:21.345985 #28143]  INFO -- : Finished
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So the first thing I did, when I needed to find a bottleneck in one part of our
system, was looking at log timings. Wrong move!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2015-05-25 16:50:42.229 [info] Started
2015-05-25 16:50:42.235 [info] Finished
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6ms - wow!&lt;/p&gt;

&lt;p&gt;It is like an old shabby van with free candies. You have a feeling that
something is not right.&lt;/p&gt;

&lt;p&gt;And when I had used &lt;code&gt;timer:tc&lt;/code&gt; (analog in Ruby - &lt;code&gt;Benchmark&lt;/code&gt;), these timings
proved to be &amp;ldquo;wrong&amp;rdquo;. And that&amp;rsquo;s because in Erlang, logger (as most things) is
a separate process with its own mailbox. What you see are &lt;strong&gt;the times of when
it received the messages&lt;/strong&gt;. In contrast, things are usually happening in the
same thread in Ruby (that is why timings are usually more accurate).&lt;/p&gt;

&lt;div style=&#34;align:center&#34;&gt;
  &lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2015-08-03-from-ruby-to-erlang/lager1.png&#34; alt=&#34;&#34;/ width=&#34;100%&#34; title=&#34;&#34;&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Lesson #2. Do not rely on lager timings, because it is a separate gen_server (i.e. you don’t know when it will process your messages).&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-high-loaded-gen-server&#34;&gt;3. High-loaded gen_server&lt;/h2&gt;

&lt;p&gt;This is more like a word of advice. When you have a &lt;code&gt;gen_server&lt;/code&gt;, which is
supposed to process, say, 1000 events per second, you can&amp;rsquo;t make any
synchronous blocking calls (e.g. to Redis) or set any locks, because soon
enough the process mailbox will be full of messages and things will become
ugly.&lt;/p&gt;

&lt;p&gt;What you should do instead, is to spawn a process per unit (an order or
something like that) or use a worker pool (&lt;a href=&#34;https://github.com/devinus/poolboy&#34;&gt;1&lt;/a&gt;,&lt;a href=&#34;https://github.com/seth/pooler&#34;&gt;2&lt;/a&gt;,&lt;a href=&#34;https://github.com/inaka/worker_pool&#34;&gt;3&lt;/a&gt;). I personally
recommend to watch &lt;a href=&#34;https://www.youtube.com/watch?v=GO_97_6w5lU&#34;&gt;this talk&lt;/a&gt; by Anthony Molinaro at Erlang Factory SF
2015, where he compares a few different options we have at the moment.&lt;/p&gt;

&lt;p&gt;If you also had some troubles during transition to another language, let me
know. I personally laugh at such moments and don&amp;rsquo;t take them too seriously,
because, you know, it just happens sometimes. The important is to learn by
these mistakes.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Заметки на полях: Изучай Erlang во имя добра!</title>
      <link>http://homeonrails.com/2015/05/zamietki-na-poliakh-izuchai-erlang-vo-imia-dobra/</link>
      <pubDate>Thu, 28 May 2015 11:51:25 +0000</pubDate>
      
      <guid>http://homeonrails.com/2015/05/zamietki-na-poliakh-izuchai-erlang-vo-imia-dobra/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/ferd&#34;&gt;Фред Хеберт&lt;/a&gt; - широко известный в Erlang сообществе
программист. Он не только написал дюжину полезных утилит и приложений, но и
замечательную книгу &lt;a href=&#34;http://www.ozon.ru/context/detail/id/28953563/?partner=akalyaev&#34;&gt;&amp;ldquo;Изучай Erlang во имя добра!&amp;rdquo;&lt;/a&gt;, которая, к тому же,
доступна онлайн совершенно бесплатно. Она в основном предназначена для тех, кто
только начинает изучать Erlang. Но и более опытные разработчики с большой
вероятностью найдут что-то новое в последних главах книги (CommonTest, Mnesia,
Distributed Erlang).&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2015-05-28-zamietki-na-poliakh-izuchai-erlang-vo-imia-dobra/book.jpg&#34; alt=&#34;&#34;/ width=&#34;270&#34; title=&#34;Изучай Erlang во имя добра!&#34;&gt;&lt;/p&gt;

&lt;p&gt;Вот лишь часть того, что я почерпнул из данной книги:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;используйте ctrl-a / ctrl-e в командной строке для перехода в начало / конец строки;&lt;/li&gt;
&lt;li&gt;;(,) и andalso(orelse) различаются в работе при построении защитных выражений (guards). Например, &lt;code&gt;when C1 ; C2&lt;/code&gt; не упадет с ошибкой, если первое условие (C1) покрашится, а вычислит второе (C2);&lt;/li&gt;
&lt;li&gt;старайтесь избегать “true&amp;rdquo; веток в условных операторах, если есть возможность покрыть все варианты (пример: &lt;code&gt;X &amp;gt;= 0, X &amp;lt; 0&lt;/code&gt;);&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.erlang.se/~bjorn/&#34;&gt;Björn Gustavsson&lt;/a&gt; из команды Erlang OTP рекомендует использовать gb_sets почти во всех случаях, ordsets, когда вам нужно простое представление и sets, когда требуется строгое сравнение =:= ;&lt;/li&gt;
&lt;li&gt;references используются, в том числе, потому что Pid может поменяться пока мы дожидаемся ответа на сообщение (процесс упал и был перезапущен супервизором);&lt;/li&gt;
&lt;li&gt;[ETS] ordered_set проигрывает по скорости рандомного чтения set, поэтому должен использоваться только для range queries;&lt;/li&gt;
&lt;li&gt;[EUnit] &lt;code&gt;?_assert&lt;/code&gt; исполняется не сразу, а после генерации теста.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;{% blockquote %}
Симметричная мультипроцессорность появилась в Erlang не сразу, а была добавлена в 2000 годах (ее можно отключить с помощью &lt;code&gt;erl -smp disable&lt;/code&gt;)
{% endblockquote %}&lt;/p&gt;

&lt;h1 id=&#34;distributed-erlang&#34;&gt;Distributed Erlang&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;узлы в Erlang общаются по TCP соединению, и, если у вас большое сообщение, остальные сообщения будут ждать очень долго. Хуже того, heartbeat сообщения могут не дойти до узла и Erlang посчитает, что узел умер;&lt;/li&gt;
&lt;li&gt;большое количество связей (link) между узлами не есть хорошо, так как приведет к всплеску количества сообщений при падении одного из них;&lt;/li&gt;
&lt;li&gt;4369 порт закреплен за &lt;a href=&#34;http://www.erlang.org/doc/man/epmd.html&#34;&gt;epmd&lt;/a&gt;. range для портов узлов можно установить через inet_dist_listen_min(max);&lt;/li&gt;
&lt;li&gt;в консоли можно использовать net_kernel:connect для связи с узлом;&lt;/li&gt;
&lt;li&gt;{global, Name} медленно разрешает конфликты имен (3 стратегии) и потерю связи с узлами. Он подходит для небольшого количества регистраций, которые нечасто меняются с течением времени;&lt;/li&gt;
&lt;li&gt;распределенные приложения OTP (OTP Distributed Applications) делают упор на то, что ошибки в основном происходят по вине аппаратного обеспечения, а не разделения сети. Если у вас по другому - OTP не для вас. Они (приложения) служат для организации failover и backover;&lt;/li&gt;
&lt;li&gt;если планируется использовать горячую замену кода (hot code reloading), то записи (records) лучше не выставлять наружу (только в рамках модуля). Иначе - боль.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;{% blockquote %}
Версии Erlang &amp;gt;= R15B01 позволяют использовать реестры помимо local и global - {via, МодульРеестра, Имя}
{% endblockquote %}&lt;/p&gt;

&lt;h1 id=&#34;mnesia&#34;&gt;Mnesia&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;хорошей идеей будет добавить префикс к названию таблиц в mnesia (так как они шарятся по всему кластеру);&lt;/li&gt;
&lt;li&gt;при написании большого приложения лучше разделить логику приложения и код mnesia (чтобы, к примеру, иметь возможность заменить транзакции на синхронные);&lt;/li&gt;
&lt;li&gt;tv:start() - GUI для просмотра таблиц.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Полезные ссылки:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://ferd.ca/&#34;&gt;Блог автора книги&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://learnyousomeerlang.com/&#34;&gt;Сама книга&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Заметки на полях: Программирование в Erlang</title>
      <link>http://homeonrails.com/2015/05/zamietki-na-poliakh-proghrammirovaniie-v-erlang/</link>
      <pubDate>Sat, 23 May 2015 15:35:04 +0000</pubDate>
      
      <guid>http://homeonrails.com/2015/05/zamietki-na-poliakh-proghrammirovaniie-v-erlang/</guid>
      <description>&lt;p&gt;Решил начать новую серию постов. Каждая статья будет представлять из себя набор
советов, инструментов, скриптов или просто умных мыслей из определенной книги.
Читать книгу или нет? Это решать вам самим.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2015-05-23-zamietki-na-poliakh-proghrammirovaniie-v-erlang/book.jpg&#34; alt=&#34;&#34;/ width=&#34;304&#34; title=&#34;Программирование в Erlang&#34;&gt;&lt;/p&gt;

&lt;p&gt;Вот что советуют Франческо Чезарини и Симон Томпсон в своей книге &lt;a href=&#34;http://www.ozon.ru/context/detail/id/30671701/?partner=akalyaev&#34;&gt;&amp;ldquo;Программирование в Erlang&amp;rdquo;&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;не меняйте приоритет процессу (за редким исключением, когда вы точно понимаете что делаете и зачем);&lt;/li&gt;
&lt;li&gt;не пропускайте сообщения в receive;&lt;/li&gt;
&lt;li&gt;не увлекайтесь =/= и =:= (равенство с проверкой по типу) - они засоряют код;&lt;/li&gt;
&lt;li&gt;создавайте процесс на &amp;ldquo;сущность&amp;rdquo; (например, сообщение, входящий файл);&lt;/li&gt;
&lt;li&gt;используйте spawn_link и spawn_monitor, а не &lt;code&gt;link(spawn(...))&lt;/code&gt; - первые атомарны;&lt;/li&gt;
&lt;li&gt;не копируйте MaxR / MaxT из модуля в модуль - их нужно выбирать с умом (&lt;a href=&#34;http://www.erlang.org/doc/man/supervisor.html&#34;&gt;http://www.erlang.org/doc/man/supervisor.html&lt;/a&gt;);&lt;/li&gt;
&lt;li&gt;используйте circuit breakers (&lt;a href=&#34;https://github.com/jlouis/fuse&#34;&gt;https://github.com/jlouis/fuse&lt;/a&gt;, &lt;a href=&#34;https://github.com/klarna/circuit_breaker&#34;&gt;https://github.com/klarna/circuit_breaker&lt;/a&gt;);&lt;/li&gt;
&lt;li&gt;не используйте infinity;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;file:write(&amp;quot;/tmp/procs.txt&amp;quot;, erlang:system_info(procs))&lt;/code&gt; - дамп информации обо всех процессах;&lt;/li&gt;
&lt;li&gt;не используйте Erlang для передачи больших кусков данных;&lt;/li&gt;
&lt;li&gt;рекомендуется отключать swap (лучше, чтобы сразу все свалилось).&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Erlang, HBase и Thrift</title>
      <link>http://homeonrails.com/2015/05/erlang-hbase-and-thrift/</link>
      <pubDate>Sat, 23 May 2015 13:30:47 +0000</pubDate>
      
      <guid>http://homeonrails.com/2015/05/erlang-hbase-and-thrift/</guid>
      <description>&lt;p&gt;И так, вы планируете читать и писать данные в HBase таблицу из Erlang&amp;rsquo;а. Что ж,
начнем с того, что клиента для Erlang&amp;rsquo;а нет :( А на выбор имеются:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;REST&lt;/li&gt;
&lt;li&gt;Thrift&lt;/li&gt;
&lt;li&gt;C/C++ Apache HBase Client&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Истории ради отмечу, что когда-то, давным давно, был шлюз для &lt;a href=&#34;http://en.wikipedia.org/wiki/Apache_Avro&#34;&gt;Avro&lt;/a&gt;. Но в
начале 2013 он канул в лету.&lt;/p&gt;

&lt;p&gt;{% blockquote &lt;a href=&#34;http://comments.gmane.org/gmane.comp.java.hadoop.hbase.user/32617&#34;&gt;http://comments.gmane.org/gmane.comp.java.hadoop.hbase.user/32617&lt;/a&gt; %}
We removed the Avro gateway because the implementation as contributed was a work in progress that was not subsequently maintained.
{% endblockquote %}&lt;/p&gt;

&lt;p&gt;Третья опция отпадает, потому как ссылка битая - &lt;a href=&#34;http://hbase.apache.org/book.html#c&#34;&gt;см. официальную
документацию&lt;/a&gt;. Видимо, в Facebook решили прекратить поддержку этого клиента.
Тем более, по &lt;a href=&#34;http://stackoverflow.com/a/13755031/820520&#34;&gt;словам пользователя stackoverflow&lt;/a&gt;, под капотом он (клиент)
вызывал Thrift API. А еще один уровень нам ни к чему.&lt;/p&gt;

&lt;p&gt;Таким образом, остаются REST и Thrift.&lt;/p&gt;

&lt;h1 id=&#34;rest&#34;&gt;Rest&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://wiki.apache.org/hadoop/Hbase/Stargate&#34;&gt;Stargate&lt;/a&gt; (REST сервер) поддерживает 3 формата передачи данных - XML, JSON
и protobufs. В целом он выглядит довольно симпатично, но а) проигрывает
thrift&amp;rsquo;у по скорости (особенно xml и json, которые тащат за собой схему) б)
могут отсутствовать некоторые параметры для требуемого вам метода.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2015-05-16-erlang-hbase-and-thrift/thrift-vs-rest1.png&#34; alt=&#34;&#34;/ width=&#34;450&#34; title=&#34;Program completion time (in seconds)&#34;&gt;
&lt;small&gt;
(Program completion time (in seconds) &lt;a href=&#34;http://blog.cloudera.com/blog/2014/04/how-to-use-the-hbase-thrift-interface-part-3-using-scans/&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://blog.cloudera.com/blog/2014/04/how-to-use-the-hbase-thrift-interface-part-3-using-scans/&#34;&gt;http://blog.cloudera.com/blog/2014/04/how-to-use-the-hbase-thrift-interface-part-3-using-scans/&lt;/a&gt;&lt;/a&gt;)
&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;Например, в protobuf схеме вы не найдете &lt;code&gt;filter&lt;/code&gt;, которые может быть нужен при выполнении &lt;code&gt;Scan&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-proto&#34;&gt;message Scanner {
  optional bytes startRow = 1;
  optional bytes endRow = 2;
  repeated bytes columns = 3;
  optional int32 batch = 4;
  optional int64 startTime = 5;
  optional int64 endTime = 6;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Хотя в XML схеме он присутствует:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;complexType name=&amp;quot;Scanner&amp;quot;&amp;gt;
    ...
    &amp;lt;sequence&amp;gt;
        &amp;lt;element name=&amp;quot;filter&amp;quot; type=&amp;quot;string&amp;quot; minOccurs=&amp;quot;0&amp;quot; maxOccurs=&amp;quot;1&amp;quot;&amp;gt;&amp;lt;/element&amp;gt;
    &amp;lt;/sequence&amp;gt;
    &amp;lt;attribute name=&amp;quot;startRow&amp;quot; type=&amp;quot;base64Binary&amp;quot;&amp;gt;&amp;lt;/attribute&amp;gt;
    &amp;lt;attribute name=&amp;quot;endRow&amp;quot; type=&amp;quot;base64Binary&amp;quot;&amp;gt;&amp;lt;/attribute&amp;gt;
    ...
&amp;lt;/complexType&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Если скорость для вас не критична, можно смело выбирать REST (REST плюс
protobufs может быть неплохим выбором). Хотя, лучше перед этим убедиться, что
все требуемые параметры (для ваших запросов) присутствуют и проблем здесь не
возникнет.&lt;/p&gt;

&lt;h1 id=&#34;thrift&#34;&gt;Thrift&lt;/h1&gt;

&lt;p&gt;У Thrift 2 недостатка:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://thrift.apache.org/lib/erl&#34;&gt;документации&lt;/a&gt; считай нет&lt;/li&gt;
&lt;li&gt;выглядит он ужасно (просьба любителей прекрасного кода на время
просмотра запастись успокоительными средствами)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Давайте рассмотрим типовые операции при работе с HBase.&lt;/p&gt;

&lt;p&gt;Для начала создадим тестовую табличку:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ~/hbase/bin/hbase shell
...
hbase(main):001:0&amp;gt; create &#39;users&#39;, &#39;data&#39;
hbase(main):007:0&amp;gt; put &#39;users&#39;, &#39;mike&#39;, &#39;data:age&#39;, 15
hbase(main):007:0&amp;gt; put &#39;users&#39;, &#39;mike&#39;, &#39;data:sex&#39;, &#39;male&#39;
hbase(main):007:0&amp;gt; put &#39;users&#39;, &#39;caleb&#39;, &#39;data:age&#39;, 21
hbase(main):007:0&amp;gt; put &#39;users&#39;, &#39;caleb&#39;, &#39;data:sex&#39;, &#39;male&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;get&#34;&gt;Get&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;{ok, C0} = thrift_client_util:new(&amp;quot;localhost&amp;quot;, 9090, hbase_thrift, [{connect_timeout, 5000}]),
{C1, {ok, Results}} = thrift_client:call(C0, getRowWithColumns, [&amp;quot;users&amp;quot;, &amp;quot;mike&amp;quot;, [&amp;quot;data:age&amp;quot;, &amp;quot;data:sex&amp;quot;], dict:new()]),
=&amp;gt; [{&#39;TRowResult&#39;,&amp;lt;&amp;lt;&amp;quot;mike&amp;quot;&amp;gt;&amp;gt;,
               {dict,2,16,16,8,80,48,
                     {[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]},
                     \{\{[],[],
                       [[&amp;lt;&amp;lt;&amp;quot;data:sex&amp;quot;&amp;gt;&amp;gt;|{&#39;TCell&#39;,&amp;lt;&amp;lt;&amp;quot;male&amp;quot;&amp;gt;&amp;gt;,1432370741107}]],
                       [],[],[],[],[],[],[],[],[],[],[],[],...\}\}},
               undefined}]
thrift_client:close(C1).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В первой строке мы устанавливаем соединение. Стоит обратить внимание на 2 вещи:
connect_timeout - таймаут на соединение, и hbase_thrift - имя нашего приложения
(обычно == OTP application name). Далее мы забираем строку с интересующими нас
столбцами по ключу.&lt;/p&gt;

&lt;h3 id=&#34;put&#34;&gt;Put&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;{ok, C0} = thrift_client_util:new(&amp;quot;localhost&amp;quot;, 9090, hbase_thrift, [{connect_timeout, 5000}]),
Mutations = [#&#39;Mutation&#39;{column= &amp;quot;data:age&amp;quot;, value= &amp;lt;&amp;lt;&amp;quot;17&amp;quot;&amp;gt;&amp;gt;}]
{C1, {ok, _}} = thrift_client:call(C0, mutateRow, [&amp;quot;users&amp;quot;, &amp;quot;mike&amp;quot;, Mutations, dict:new()]),
thrift_client:close(C1).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Новое значение для столбца в записи #&amp;lsquo;Mutation&amp;rsquo; может быть либо строкой, либо
binary (&amp;lt;&amp;lt;&amp;ldquo;17&amp;rdquo;&amp;gt;&amp;gt;).&lt;/p&gt;

&lt;h3 id=&#34;scan&#34;&gt;Scan&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;{ok, C0} = thrift_client_util:new(&amp;quot;localhost&amp;quot;, 9090, hbase_thrift, [{connect_timeout, 5000}]),
Scan = #&#39;TScan&#39;{&#39;columns&#39;=[&amp;quot;data:sex&amp;quot;]},
{C1, {ok, ScannerId}} = thrift_client:call(C0, scannerOpenWithScan, [&amp;quot;users&amp;quot;, Scan, dict:new()]),
{C2, {ok, Results}} = thrift_client:call(C1, scannerGetList, [ScannerId, 10]),
=&amp;gt; [#&#39;TRowResult&#39;{row = &amp;lt;&amp;lt;&amp;quot;caleb&amp;quot;&amp;gt;&amp;gt;,
               columns = {dict,1,16,16,8,80,48,
                               {[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]},
                               \{\{[],[],
                                 [[&amp;lt;&amp;lt;&amp;quot;data:sex&amp;quot;&amp;gt;&amp;gt;|
                                   #&#39;TCell&#39;{value = &amp;lt;&amp;lt;&amp;quot;male&amp;quot;&amp;gt;&amp;gt;,timestamp = 1432372800621}]],
                                 [],[],[],[],[],[],[],[],[],[],[],[],...\}\}},
               sortedColumns = undefined},
    #&#39;TRowResult&#39;{row = &amp;lt;&amp;lt;&amp;quot;mike&amp;quot;&amp;gt;&amp;gt;,
               columns = {dict,1,16,16,8,80,48,
                               {[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]},
                               \{\{[],[],
                                 [[&amp;lt;&amp;lt;&amp;quot;data:sex&amp;quot;&amp;gt;&amp;gt;|
                                   #&#39;TCell&#39;{value = &amp;lt;&amp;lt;&amp;quot;male&amp;quot;&amp;gt;&amp;gt;,timestamp = 1432370741107}]],
                                 [],[],[],[],[],[],[],[],[],[],[],...\}\}},
               sortedColumns = undefined}]
{C3, {ok, _}} = thrift_client:call(C2, scannerClose, [ScannerId]),
thrift_client:close(C3).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;У #&amp;lsquo;Scan&amp;rsquo; можно задать не только столбцы, но и другие параметры: стартовую
строку, конечную строку, фильтр (рассмотрен ниже).&lt;/p&gt;

&lt;h3 id=&#34;scan-с-фильтром-и-начальной-строкой&#34;&gt;Scan с фильтром и начальной строкой&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;{ok, C0} = thrift_client_util:new(&amp;quot;localhost&amp;quot;, 9090, hbase_thrift, [{connect_timeout, 5000}]),
FilterString = &amp;quot;(SingleColumnValueFilter(&#39;data&#39;, &#39;sex&#39;, =, &#39;binary:male&#39;, true, true))&amp;quot;,
Scan = #&#39;TScan&#39;{&#39;filterString&#39;=FilterString,&#39;startRow&#39;=&amp;quot;caleb1&amp;quot;,&#39;columns&#39;=[&amp;quot;data:sex&amp;quot;]},
{C1, {ok, ScannerId}} = thrift_client:call(C0, scannerOpenWithScan, [&amp;quot;users&amp;quot;, Scan, dict:new()]),
{C2, {ok, Results}} = thrift_client:call(C1, scannerGetList, [ScannerId, 10]),
=&amp;gt; [#&#39;TRowResult&#39;{row = &amp;lt;&amp;lt;&amp;quot;mike&amp;quot;&amp;gt;&amp;gt;,
               columns = {dict,1,16,16,8,80,48,
                               {[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]},
                               \{\{[],[],
                                 [[&amp;lt;&amp;lt;&amp;quot;data:sex&amp;quot;&amp;gt;&amp;gt;|
                                   #&#39;TCell&#39;{value = &amp;lt;&amp;lt;&amp;quot;male&amp;quot;&amp;gt;&amp;gt;,timestamp = 1432370741107}]],
                                 [],[],[],[],[],[],[],[],[],[],[],[],...\}\}},
               sortedColumns = undefined}]
{C3, {ok, _}} = thrift_client:call(C2, scannerClose, [ScannerId]),
thrift_client:close(C3).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Здесь мы фильтруем всех пользователей по атрибуту sex. Последние 2 параметра
сообщают HBase, что надо исключить из результирующей выборки строки, где данный
атрибут отсутствует и забрать только последнюю версию (по умолчанию HBase
хранит 5 версий). &lt;a href=&#34;https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/SingleColumnValueFilter.html&#34;&gt;Документация по
SingleColumnValueFilter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Обратите также внимание на значение startRow - &lt;code&gt;caleb1&lt;/code&gt;. Постфикс (1 байт в
конце) нужен для того, чтобы не включать данную строку в результат.&lt;/p&gt;

&lt;h3 id=&#34;delete&#34;&gt;Delete&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;{ok, C0} = thrift_client_util:new(&amp;quot;localhost&amp;quot;, 9090, hbase_thrift, [{connect_timeout, 5000}]),
{C1, {ok, _}} = thrift_client:call(C0, deleteAll, [&amp;quot;users&amp;quot;, &amp;quot;caleb&amp;quot;, &amp;quot;data:age&amp;quot;, dict:new()]),
thrift_client:close(C1).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;удалит столбец age (все версии) у пользователя caleb.&lt;/p&gt;

&lt;h1 id=&#34;заключение&#34;&gt;Заключение&lt;/h1&gt;

&lt;p&gt;С Thrift&amp;rsquo;ом работать можно, если приноровиться. Конечно, проблемы еще есть
(&lt;a href=&#34;https://issues.apache.org/jira/browse/THRIFT-2842https://issues.apache.org/jira/browse/THRIFT-2842&#34;&gt;https://issues.apache.org/jira/browse/THRIFT-2842https://issues.apache.org/jira/browse/THRIFT-2842&lt;/a&gt;),
но они решаются.&lt;/p&gt;

&lt;p&gt;Полезные ссылки:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://wiki.apache.org/hadoop/Hbase/ThriftApi&#34;&gt;http://wiki.apache.org/hadoop/Hbase/ThriftApi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rambocoder.com/?p=142&#34;&gt;http://rambocoder.com/?p=142&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://kungfooguru.wordpress.com/2009/08/31/erlang-thrift-and-hbase/&#34;&gt;http://kungfooguru.wordpress.com/2009/08/31/erlang-thrift-and-hbase/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Опции meck:new</title>
      <link>http://homeonrails.com/2015/03/meck-new-options/</link>
      <pubDate>Tue, 03 Mar 2015 11:04:41 +0000</pubDate>
      
      <guid>http://homeonrails.com/2015/03/meck-new-options/</guid>
      <description>&lt;p&gt;Документация по &lt;a href=&#34;https://github.com/eproxus/meck&#34;&gt;meck&lt;/a&gt;&amp;hellip; скажем так, не блещет. Давайте разберем опции &lt;code&gt;meck:new&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;passthrough&lt;/code&gt; пробрасывает функции meck-модуля (string_meck) в оригинальный модуль (string)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;meck:new(string, [passthrough]),
meck:expect(string, char_at,
    fun(0) -&amp;gt;
        $a;
    (Pos) -&amp;gt;
        meck:passthrough([Pos])
end),
?assert(meck:validate(string)).
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;no_link&lt;/code&gt; не связывать meck процесс с вызывающим процессом. В зависимости от значения используется либо &lt;code&gt;gen_server:start_link&lt;/code&gt;, либо &lt;code&gt;gen_server:start&lt;/code&gt;. По умолчанию при падении вызывающего процесса meck выгрузит все модули. &lt;strong&gt;Не понимаю зачем может потребоваться не связывать эти процессы.&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;unstick&lt;/code&gt; для мокинга stdlib, kernel или compiler. По умолчанию Erlang запрещает перезагружать данные модули в целях безопасности.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;no_passthrough_cover&lt;/code&gt; запрещает отслеживать покрытие тестами passthrough вызовов. &lt;strong&gt;Видимо когда-то были проблемы при взаимодействии cover и meck и, в результате, родилась данная опция.&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;{spawn_opt, list()}&lt;/code&gt; позволяет указать &lt;code&gt;spawn_opt&lt;/code&gt; для &lt;code&gt;gen_server:start_link&lt;/code&gt;. Подробнее &lt;a href=&#34;http://erlang.org/doc/man/erlang.html#spawn_opt-4&#34;&gt;http://erlang.org/doc/man/erlang.html#spawn_opt-4&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;no_history&lt;/code&gt; - не записывать историю.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;non_strict&lt;/code&gt; позволяет создать expectation для несуществующей функции или даже создать несуществующий модуль. &lt;strong&gt;Не думаю, что эта хорошая практика.&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;{stub_all, &#39;{@link ret_spec()}&#39;}&lt;/code&gt; замокает все функции модуля и будет возвращать то, что указано вторым параметром.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-erlang&#34;&gt;meck:new(string, [stub_all]),
?assertEqual(ok, string:colorize()).

meck:new(string, [{stub_all, true}]),
?assertEqual(true, string:contains($a)).

meck:new(string, [{stub_all, meck:seq([$a, $b, $c])}]),
?assertEqual($a, string:char_at(1)),
?assertEqual($b, string:char_at(2)),
?assertEqual($c, string:char_at(3)),
?assertEqual($c, string:char_at(4)).

meck:new(string, [{stub_all, meck:loop([$a, $b, $c])}]),
?assertEqual($a, string:char_at(1)),
?assertEqual($b, string:char_at(2)),
?assertEqual($c, string:char_at(3)),
?assertEqual($a, string:char_at(4)). %% заметили разницу между seq?
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>