<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorials on Home on Rails</title>
    <link>http://homeonrails.com/tags/tutorials/index.xml</link>
    <description>Recent content in Tutorials on Home on Rails</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>All rights reserved - 2017</copyright>
    <atom:link href="http://homeonrails.com/tags/tutorials/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Signing Git Commits</title>
      <link>http://homeonrails.com/2017/01/signing-git-commits/</link>
      <pubDate>Sat, 14 Jan 2017 21:14:14 +0400</pubDate>
      
      <guid>http://homeonrails.com/2017/01/signing-git-commits/</guid>
      <description>

&lt;p&gt;Решили у себя в команде, что будем подписывать коммиты и тэги. У git&amp;rsquo;а уже
давно имеется данная возможность. Но мало кто ей пользуется. Благодаря этому
возможны такие смешные поделки как
&lt;a href=&#34;https://github.com/jayphelps/git-blame-someone-else&#34;&gt;git-blame-someone-else&lt;/a&gt;.
Если же вы подписываете коммит своей подписью, то уверенности в том, что автор
действительно ВЫ, прибавляется.&lt;/p&gt;

&lt;p&gt;Github в &lt;a href=&#34;https://github.com/blog/2144-gpg-signature-verification&#34;&gt;апреле прошлого
года&lt;/a&gt; начал показывать
зеленый бейджик когда коммит подписан. Вот как он выглядит:&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;img-rounded&#34; src=&#34;http://homeonrails.com/images/posts/2017-01-14-signing-git-commits/github.png&#34; alt=&#34;&#34; title=&#34;&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Создать подпись и настроить git очень просто. Итак, давайте сделаем это:&lt;/p&gt;

&lt;h3 id=&#34;1-создаем-подпись&#34;&gt;1. Создаем подпись&lt;/h3&gt;

&lt;p&gt;Ставим gpg:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Ubuntu
sudo apt-get install gpa seahorse
# Mac
brew install gpg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Создаем RSA пару (публичный и приватный ключ):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gpg --gen-key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(размер не ниже 2048, но и &lt;a href=&#34;https://gnupg.org/faq/gnupg-faq.html#no_default_of_rsa4096&#34;&gt;больше не особо
нужно&lt;/a&gt;; срок
годности по желанию)&lt;/p&gt;

&lt;p&gt;Копируем полученный публичный ключ на &lt;a href=&#34;https://github.com/settings/keys&#34;&gt;Github&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gpg --list-secret-keys --keyid-format LONG

-------------------------------
sec   2048R/&amp;lt;COPY_LONG_KEY&amp;gt;  2017-01-14 [expires: 2019-01-14]
uid                          User Name &amp;lt;user.name@email.com&amp;gt;
ssb   2048R/098AA7C27DD57ACC 2017-01-14

gpg --armor --export &amp;lt;PASTE_LONG_KEY_HERE&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-настраиваем-git&#34;&gt;2. Настраиваем git&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;gpg --list-secret-keys

-------------------------------
sec   2048R/&amp;lt;COPY_SHORT_KEY&amp;gt; 2017-01-14 [expires: 2019-01-14]
uid                          User Name &amp;lt;user.name@email.com&amp;gt;
ssb   2048R/7DD57ACC         2017-01-14

git config --global user.signingKey &amp;lt;PASTE_SHORT_KEY_HERE&amp;gt;
git config --global commit.gpgsign true
git config --global tag.gpgsign true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(можно настроить индивидуально под каждый репозиторий).&lt;/p&gt;

&lt;h3 id=&#34;3-кэшируем-пароль&#34;&gt;3. Кэшируем пароль&lt;/h3&gt;

&lt;p&gt;чтобы не вводить его каждый раз при подписи.&lt;/p&gt;

&lt;p&gt;Если вы пользователь Mac OS, то ставим &lt;a href=&#34;https://gpgtools.org/&#34;&gt;GPG Suite&lt;/a&gt;,
который интегрируется с Mac OS keychain.&lt;/p&gt;

&lt;p&gt;Если пользуетесь Linux, то придется воспользоваться встроенным &lt;code&gt;gpg-agent&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Создаем конфиг &lt;code&gt;.gnupg/gpg-agent.conf&lt;/code&gt; со следующим содержимым:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;default-cache-ttl 28800
max-cache-ttl 28800
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;28800 - 8 часов (кто-то ставит 1 час).&lt;/p&gt;

&lt;p&gt;В конфиге &lt;code&gt;.gnupg/gpg.conf&lt;/code&gt; указываем:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use-agent
batch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;batch&lt;/code&gt; убирает противные сообщения вида: &lt;code&gt;You need a passphrase to unlock the
secret key&lt;/code&gt;. Да, они по неведомой причине появляются даже, если агент
закэшировал пароль.&lt;/p&gt;

&lt;p&gt;Не забываем запустить &lt;code&gt;gpg-agent&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;fish:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if not begin
    # Is the agent running already? Does the agent-info file exist, and if so,
    # is there a process with the pid given in the file?
    [ -f ~/.gpg-agent-info ]
    and kill -0 (cut -d : -f 2 ~/.gpg-agent-info) ^/dev/null
end
    # no, it is not running. Start it!
    gpg-agent --daemon --no-grab --write-env-file ~/.gpg-agent-info &amp;gt;/dev/null ^&amp;amp;1
end
# get the agent info from the info file, and export it so GPG can see it.
set -gx GPG_AGENT_INFO (cut -c 16- ~/.gpg-agent-info)
set -gx GPG_TTY (tty)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;или &lt;a href=&#34;https://github.com/ErinCall/Dotfiles/blob/master/.bashrc#L32-L40&#34;&gt;bash&lt;/a&gt;
или напрямую &lt;code&gt;gpg-agent --daemon&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;4-коммитим-что-угодно-и-идем-смотреть-результат-на-github&#34;&gt;4. Коммитим что угодно и идем смотреть результат на Github&lt;/h2&gt;

&lt;p&gt;Материалы:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.erincall.com/p/signing-your-git-commits-with-gpg&#34;&gt;Signing Your Git Commits With GPG&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/ankurk91/c4f0e23d76ef868b139f3c28bde057fc&#34;&gt;Github : Signing commits using GPG (Ubuntu/Mac)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/bmhatfield/cc21ec0a3a2df963bffa3c1f884b676b&#34;&gt;Automatic Git commit signing with GPG on OSX&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Copy and paste between Vim and OS</title>
      <link>http://homeonrails.com/2014/01/copy-and-paste-between-vim-and-os/</link>
      <pubDate>Thu, 09 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://homeonrails.com/2014/01/copy-and-paste-between-vim-and-os/</guid>
      <description>&lt;p&gt;When I first encountered this problem it slightly
puzzled me. &amp;ldquo;Why can not I press &lt;code&gt;ctrl-c&lt;/code&gt; to copy the text and
&lt;code&gt;ctrl-v&lt;/code&gt; to paste?&amp;ldquo;- I asked myself. Indeed, the majority of source code editors
able to do this. And yes, I got used to this dammit!&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Well, Vim is primarily a console text editor. Of course, there is a GUI version - GVim (or MacVim for MacOS), but most prefer to stay in the console, where we can use such wonderful tools as &lt;a href=&#34;http://en.wikipedia.org/wiki/Tmux&#34;&gt;tmux&lt;/a&gt; and &lt;a href=&#34;https://github.com/remiprev/teamocil&#34;&gt;teamochil&lt;/a&gt; *.&lt;/p&gt;

&lt;h3 id=&#34;first-attempt&#34;&gt;First attempt&lt;/h3&gt;

&lt;p&gt;The first more or less acceptable solution offered &lt;a href=&#34;https://twitter.com/gumayunov&#34;&gt;Victor Gumayunov&lt;/a&gt;. Few people know, but if you press and hold &lt;code&gt;ctrl + alt&lt;/code&gt;, you will be able to select a text block using the mouse and, by clicking its right button, copy it.&lt;/p&gt;

&lt;h3 id=&#34;second-attempt&#34;&gt;Second attempt&lt;/h3&gt;

&lt;p&gt;And at first, it suited me. But it has lasted a short time and I started
looking for other ways out. The next approach was to use of custom bindings for tmux, which use xclip utility (pbcopy on MacOS) to copy the contents of the system&amp;rsquo;s buffer into tmux&amp;rsquo;s buffer and back.&lt;/p&gt;

&lt;p&gt;For this you was have to write:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# move x clipboard into tmux paste buffer
bind C-p run &amp;quot;tmux set-buffer \&amp;quot;$(xclip -o)\&amp;quot;; tmux paste-buffer&amp;quot;
# move tmux copy buffer into x clipboard
bind C-y run &amp;quot;tmux save-buffer - | xclip -i&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in your &lt;code&gt;.tmux.conf&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But do not rush to do it :)&lt;/p&gt;

&lt;h3 id=&#34;third-attempt-the-lucky-one&#34;&gt;Third attempt (the lucky one)&lt;/h3&gt;

&lt;p&gt;While getting to know Vim more tightly, I learned that it has support
for system buffer. To work with it, Vim has two registers &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt;
(see &lt;code&gt;:h registers&lt;/code&gt;). &amp;ldquo;Sounds great&amp;rdquo; - I thought.&lt;/p&gt;

&lt;p&gt;One catch - Vim must be compiled with &lt;code&gt;+clipboard&lt;/code&gt;. To check whether you have support for clipboard run:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vim --version | grep clipboard
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The easiest way to fix this &lt;strong&gt;for most Linux&amp;rsquo;es&lt;/strong&gt; is to install GVim (but continue to use its console version).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo apt-get install vim-gnome
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;For MacOS&lt;/strong&gt; you can get Vim with &lt;code&gt;+clipboard&lt;/code&gt; via Homebrew or download and install MacVim &lt;a href=&#34;http://code.google.com/p/macvim/downloads/list&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ brew install vim
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Look inside /Applications/MacVim.app/Contents/MacOS, and you’ll see that the app provides two binaries: MacVim, which launches the GUI, and Vim, which runs in the Terminal with the same feature set. Both versions include the &lt;code&gt;+clipboard&lt;/code&gt; feature.&lt;/p&gt;

&lt;p&gt;The last thing left to do - something to get rid of the need to
to type &lt;code&gt;&amp;quot;*p&lt;/code&gt; and &lt;code&gt;&amp;quot;*y&lt;/code&gt; prefixes. I don&amp;rsquo;t want copy and paste between Vim and OS was some special occasion, I want everything to be transparent to the user. It turned out, you just need to add this line to your &lt;code&gt;.vimrc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;set clipboard=unnamed &amp;quot; or unnamedplus if you have X11
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now all operations such as &lt;code&gt;yy&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt;, and &lt;code&gt;p&lt;/code&gt; work with the clipboard. No need to prefix them with &lt;code&gt;&amp;quot;*&lt;/code&gt; or &lt;code&gt;&amp;quot;+&lt;/code&gt;. Sounds like magic, right?!&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;//www.youtube.com/embed/x19YZF4YfLs&#34; frameborder=&#34;0&#34; allowfullscreen=&#34;true&#34;&gt;       &lt;/iframe&gt;

&lt;p&gt;* these utilities are among the best in my humble opinion and they are helping me every day&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>По следам RailsRumble 2013</title>
      <link>http://homeonrails.com/2013/10/in-the-wake-of-railsrumble2013/</link>
      <pubDate>Wed, 23 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>http://homeonrails.com/2013/10/in-the-wake-of-railsrumble2013/</guid>
      <description>&lt;p&gt;В этом году я в очередной раз участвовал в
&lt;a href=&#34;http://railsrumble.com&#34;&gt;RailsRumble&lt;/a&gt;. Если кто не в курсе, RailsRumble
- это 48 часовой хакатон, в рамках которого команды со всего света соревнуются
между собой путем написания Web-приложений на Ruby on Rails
(или любого другого &#34;Rack based&#34; Web фреймворка). Идеи самые
разнообразные! Например, есть приложение для сравнения новостей из
разных источников (The New York Times VS Fox News), приложение для
организаторов конференций, приложение которое показывает треки из видео
на YouTube или Vimeo.&lt;/p&gt;

&lt;!--more--&gt;

&amp;nbsp;

&lt;div align=&#34;center&#34;&gt;
  &lt;a href=&#34;http://booksviabooks.com&#34; title=&#34;BooksViaBooks&#34;&gt;
    &lt;img class=&#34;img-rounded&#34;
    src=&#34;http://homeonrails.com/images/posts/2013-10-23-in-the-wake-of-railsrumble2013/booksviabooks.png&#34;
    alt=&#34;BooksViaBooks&#34;/ width=&#34;450&#34;&gt;
  &lt;/a&gt;
&lt;/div&gt;

&amp;nbsp;

&lt;p&gt;Мы вместе с Андреем Кулаковым, Дмитрием Висловым и Михаилом Столбовым
написали сервис &lt;a href=&#34;http://booksviabooks.com&#34;&gt;BooksViaBooks&lt;/a&gt;, который
позволяет довольно легко посмотреть рекомендации автора по конкретной
книге.&lt;/p&gt;

&lt;p&gt;Нередко, когда вы читаете книгу, автор советует вам издания других авторов: &#34;Если вы еще не прочитали данную книгу, советую незамедлительно сделать это&#34; или &#34;Чтобы узнать больше об области X, рекомендую прочесть книгу X&#34;.
К сожалению, многие авторы не публикуют список своих рекомендаций в конце книги, так что вам приходится либо заново просматривать книгу, либо делать заметки на полях по мере прочтения&#34;.&lt;/p&gt;

&lt;p&gt;Чтобы упростить себе и другим людям жизнь, мы и решили создать
BooksViaBooks.&lt;/p&gt;

&lt;p&gt;Почему я уже второй раз участвую в данном мероприятии? Все очень
просто:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Есть возможность попробовать какие-то новые технологии (связи книг хранятся в Neo4j)&lt;/li&gt;
  &lt;li&gt;Есть возможность попробовать себя в другой роли (дизайн BooksViaBooks разработан Андреем Кулаковым - Ruby разработчиком)&lt;/li&gt;
  &lt;li&gt;Это весело (можно программировать и, вместе с этим, смотреть Time with Finn &amp; Jake :) )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Вообще от России выступало порядка 10-15 команд. Подробнее в посте на
&lt;a href=&#34;http://habrahabr.ru/post/198426/&#34;&gt;habrahabr.ru&lt;/a&gt;. Если вам приглянулось какое-либо приложение, можно
проголосовать за него добавив в Favorites.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>10 команд, которыми вы пользуетесь чаще всего</title>
      <link>http://homeonrails.com/2013/07/top-10-commands-you-currently-use/</link>
      <pubDate>Sun, 28 Jul 2013 00:00:00 +0000</pubDate>
      
      <guid>http://homeonrails.com/2013/07/top-10-commands-you-currently-use/</guid>
      <description>&lt;p&gt;Порой, если вы активно пользуетесь командной строкой, вы начинаете
замечать, что набираете некоторые команды по многу раз. Неужели вам не
лень каждый раз набирать &lt;code&gt;vagrant up&lt;/code&gt; или &lt;code&gt;git checkout
feature/awesome-feature&lt;/code&gt;? Если да и вы стремитесь к повышению
продуктивности своей работы, то в командной оболочке linux есть отличное средство,
которое нам поможет - алиасы.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Сначала надо получить список наиболее часто используемых команд:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;history | awk &#39;{CMD[$2]++;count++;}END { for (a in CMD)print CMD[a] &amp;quot; &amp;quot; CMD[a]/count*100 &amp;quot;% &amp;quot; a;}&#39; | grep -v &amp;quot;./&amp;quot; | column -c3 -s &amp;quot; &amp;quot; -t | sort -nr | nl |  head -n10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;awk&lt;/code&gt; сохраняет команду и количество ее вхождений в
историю. Затем результат печатается, фильтруются скрипты вида
&lt;code&gt;./something&lt;/code&gt;, сортируется и обрезается до нужной длины.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://linux.byexamples.com/archives/332/what-is-your-10-common-linux-commands/&#34;&gt;Источник&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Пример вывода:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;13185  31.8532%   git
21430  14.3014%   gst
3706   7.301406071%   vim
4687   6.87069%   cd
5618   6.18062%   vagrant
6404   4.0404%    sudo
7252   2.52025%   tmux
8232   2.32023%   g
9197   1.9702%    ls
10190  1.90019%   gc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Основываясь на выводе выше, можно сказать что я очень часто пользуюсь
git, так что неплохо бы создать алиас для него и команд ниже.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;alias g=&amp;quot;git&amp;quot;
alias v=&amp;quot;vim&amp;quot;
alias l=&amp;quot;ls -al&amp;quot;
alias c=&amp;quot;git commit -m&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Мне очень нравятся однобуквенные алиасы. Хотя на многое их явно не
хватит.&lt;/p&gt;

&lt;p&gt;Также можно проанализировать только команды vagrant&amp;rsquo;а (subcommands) или любой
другой программы слегка модифицировав предыдущий скрипт:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;history|grep vagrant| awk &#39;{CMD[$3]++;count++;}END { for (a in CMD)print CMD[a] &amp;quot; &amp;quot; CMD[a]/count*100 &amp;quot;% &amp;quot; a;}&#39; | grep -v &amp;quot;./&amp;quot; | column -c3 -s &amp;quot; &amp;quot; -t | sort -nr | nl |  head -n10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Пример вывода:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1   193  23.9752%   ssh
2   166  20.6211%   up
3   98   12.1739%   halt
4   63   7.82609%   reload
5   37   4.59627%   destroy
6   31   3.85093%   TEAMOCIL=1;
7   18   2.23602%   provision
8   14   1.73913%   box
9   9    1.11801%   solo
10  8    0.993789%  -r
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Для vagrant мы заведем такой набор:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;alias v=&amp;quot;vagrant&amp;quot;
alias vst=&amp;quot;vagrant status&amp;quot;
alias vup=&amp;quot;vagrant up&amp;quot;
alias vpr=&amp;quot;vagrant provision&amp;quot;
alias vhl=&amp;quot;vagrant halt&amp;quot;
alias vre=&amp;quot;vagrant reload&amp;quot;
alias vssh=&amp;quot;vagrant ssh&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Если вы пользуетесь zsh, то рекомендую взглянуть на &lt;a href=&#34;https://github.com/robbyrussell/oh-my-zsh&#34;&gt;oh-my-zsh&lt;/a&gt;, которая
предлагает большое количесво плагинов с алиасами и автодополнением.
Конечно, они во многом избыточны (стоит хотя бы взглянуть на &lt;a href=&#34;http://jasonm23.github.io/oh-my-git-aliases.html&#34;&gt;список
команд плагина git&lt;/a&gt;), но если вас это устраивает, то можно смело их
использовать.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Как результат, мы повышаем продуктивность и, что немаловажно, снижаем нагрузку на наши
пальцы.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;P.S. очень рекомендую посмотреть доклад &lt;a href=&#34;http://www.youtube.com/watch?v=SkdrYWhh-8s&#34;&gt;Ben Orenstein - Write code faster: expert-level vim (Railsberry 2012)&lt;/a&gt;,
в котором Бен рассказывает очень правильные подходы в работе с vim&amp;rsquo;ом. Даже если вы не
пользуетесь vim&amp;rsquo;ом, многие вещи можно переложить на ваш любимый редактор, будь то Emacs, Sublime или любой другой.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>AssociationCountValidator</title>
      <link>http://homeonrails.com/2012/10/associationcountvalidator/</link>
      <pubDate>Wed, 10 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>http://homeonrails.com/2012/10/associationcountvalidator/</guid>
      <description>&lt;p&gt;As a result of my &lt;a href=&#34;http://homeonrails.com/2012/10/validating-nested-associations-in-rails&#34;&gt;previous blog post&lt;/a&gt;
about validating nested associations, I wrote custom validator for Rails 3.
It is intended to help you to validate records count in a given association.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# lib/association_count_validator.rb
class AssociationCountValidator &amp;lt; ActiveModel::Validations::LengthValidator
  MESSAGES = { :wrong_length =&amp;gt; :association_count_invalid,
               :too_short =&amp;gt; :association_count_greater_than_or_equal_to,
               :too_long =&amp;gt; :association_count_less_than_or_equal_to }.freeze

  def initialize(options)
    MESSAGES.each { |key, message| options[key] ||= message }
    super
  end

  def validate_each(record, attribute, value)
    existing_records = record.send(attribute).reject(&amp;amp;:marked_for_destruction?)
    super(record, attribute, existing_records)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Probably, you noticed that this is just a wrapper over the standard &lt;code&gt;LengthValidator&lt;/code&gt;.
This has a big advantage - all options, provided by the basic validator, are supported.
And it correctly handles the situation with marked for destruction records,
which was mentioned in the previous post.&lt;/p&gt;

&lt;p&gt;Usage:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Company &amp;lt; ActiveRecord::Base
  OFFICES_COUNT_MIN = 1

  attr_accessible :name, :offices_attributes

  validates :name, presence: true
  validates :offices, association_count: { minimum: OFFICES_COUNT_MIN }

  has_many :offices, inverse_of: :company

  accepts_nested_attributes_for :offices, allow_destroy: true
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Do not forget to add custom error messages to your localization files.&lt;/p&gt;

&lt;p&gt;Example for &lt;code&gt;en&lt;/code&gt; culture:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;en:
  errors:
    messages:
      association_count_less_than_or_equal_to:
        one: count must be less than 1
        other: count must be less than or equal to %{count}
      association_count_greater_than_or_equal_to:
        one: count must be greater than 1
        other: count must be greater than or equal to %{count}
      association_count_invalid:
        one: count is invalid (must be equal to 1)
        other: count is invalid (must be equal to %{count})
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Validating nested associations in Rails</title>
      <link>http://homeonrails.com/2012/10/validating-nested-associations-in-rails/</link>
      <pubDate>Mon, 08 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>http://homeonrails.com/2012/10/validating-nested-associations-in-rails/</guid>
      <description>&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;

&lt;p&gt;Rails provide a wide range of options for creating rich forms for your models.
This can be a simple form for one object, or the form for many related objects.
Usually it is a parent-children relations. If you are not familiar with such terms
as &lt;a href=&#34;http://api.rubyonrails.org/classes/ActionView/Helpers/FormHelper.html#M001605&#34;&gt;form_for&lt;/a&gt;
or &lt;a href=&#34;http://api.rubyonrails.org/classes/ActiveRecord/NestedAttributes/ClassMethods.html#M002132&#34;&gt;accepts_nested_attributes_for&lt;/a&gt;,
I strongly recommend taking a look at this article &lt;a href=&#34;http://rubysource.com/complex-rails-forms-with-nested-attributes/&#34;&gt;Complex Rails Forms with Nested Attributes&lt;/a&gt;,
written by &lt;a href=&#34;http://xaviershay.com/&#34;&gt;Xavier Shay&lt;/a&gt;, which will show your how you can create complex forms with Rails.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;an-example&#34;&gt;An example&lt;/h2&gt;

&lt;p&gt;Suppose, we have a model called &lt;code&gt;Company&lt;/code&gt;. And the company may have several offices.
Lets define these two models.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Company &amp;lt; ActiveRecord::Base
  attr_accessible :name, :offices_attributes
  validates :name, presence: true
  has_many :offices
  accepts_nested_attributes_for :offices, allow_destroy: true
end

class Company::Office &amp;lt; ActiveRecord::Base
  attr_accessible :company_id, :name
  validates :name, presence: true
  belongs_to :company
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both company and office have names. The company could have zero or more offices.&lt;/p&gt;

&lt;p&gt;By including &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt; it becomes possible to access
offices attributes inside our &lt;code&gt;Company&lt;/code&gt; model.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; c = Company.create(name: &#39;Mars LLC&#39;)
&amp;gt;   =&amp;gt; #&amp;lt;Company id: 1, name: &amp;quot;Mars LLC&amp;quot;, created_at: &amp;quot;2012-10-08 19:16:44&amp;quot;, updated_at: &amp;quot;2012-10-08 19:16:44&amp;quot;&amp;gt;

# add two new offices
&amp;gt; c.offices_attributes = [{ name: &#39;North America&#39; }, { name: &#39;Europe&#39; }]
&amp;gt;   =&amp;gt; [{:name=&amp;gt;&amp;quot;North America&amp;quot;}, {:name=&amp;gt;&amp;quot;Europe&amp;quot;}]
&amp;gt; c.save
&amp;gt; c.offices
&amp;gt;   =&amp;gt; [#&amp;lt;Company::Office id: 1, company_id: 1, name: &amp;quot;North America&amp;quot;, created_at: &amp;quot;2012-10-08 19:21:54&amp;quot;, updated_at: &amp;quot;2012-10-08 19:21:54&amp;quot;&amp;gt;, #&amp;lt;Company::Office id: 2, company_id: 1, name: &amp;quot;Europe&amp;quot;, created_at: &amp;quot;2012-10-08 19:21:54&amp;quot;, updated_at: &amp;quot;2012-10-08 19:21:54&amp;quot;&amp;gt;]

# edit office in North America
&amp;gt; c.offices_attributes = [{ id: 1, name: &amp;quot;North America (it&#39;s cold out there)&amp;quot; }]
&amp;gt;   =&amp;gt; [{:id=&amp;gt;1, :name=&amp;gt;&amp;quot;North America (it&#39;s cold out there)&amp;quot;}]
&amp;gt; c.save
&amp;gt; c.offices
&amp;gt;   =&amp;gt; [#&amp;lt;Company::Office id: 1, company_id: 1, name: &amp;quot;North America (it&#39;s cold out there)&amp;quot;, created_at: &amp;quot;2012-10-08 19:21:54&amp;quot;, updated_at: &amp;quot;2012-10-08 19:25:18&amp;quot;&amp;gt;, #&amp;lt;Company::Office id: 2, company_id: 1, name: &amp;quot;Europe&amp;quot;, created_at: &amp;quot;2012-10-08 19:21:54&amp;quot;, updated_at: &amp;quot;2012-10-08 19:21:54&amp;quot;&amp;gt;]

# delete an office in Europe
&amp;gt; c.offices_attributes = [{ id: 2, _destroy: &#39;1&#39; }]
&amp;gt;   =&amp;gt; [{:id=&amp;gt;2, :_destroy=&amp;gt;&amp;quot;1&amp;quot;}]
&amp;gt; c.save
&amp;gt; c.offices
&amp;gt;   =&amp;gt; [#&amp;lt;Company::Office id: 1, company_id: 1, name: &amp;quot;North America (it&#39;s cold out there)&amp;quot;, created_at: &amp;quot;2012-10-08 19:21:54&amp;quot;, updated_at: &amp;quot;2012-10-08 19:25:18&amp;quot;&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two basic options, that you should know when dealing with &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;allow_destroy&lt;/code&gt; - allows to destroy objects (&lt;code&gt;false&lt;/code&gt; by default)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reject_if&lt;/code&gt; - rejects the records, based on the given  &lt;code&gt;Proc&lt;/code&gt; or
a &lt;code&gt;Symbol&lt;/code&gt; pointing to a method. This one is simular to the &lt;code&gt;Enumerable::reject&lt;/code&gt; method (&lt;a href=&#34;http://www.ruby-doc.org/core-1.9.3/Enumerable.html#method-i-reject&#34;&gt;Doc&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Take a look at the other supported options on &lt;a href=&#34;http://apidock.com/rails/ActiveRecord/NestedAttributes/ClassMethods/accepts_nested_attributes_for&#34;&gt;apidock.com&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;validating-nested-attributes&#34;&gt;Validating nested attributes&lt;/h3&gt;

&lt;p&gt;Except the basic validation, you can use &lt;code&gt;reject_if&lt;/code&gt; option to validate a nested object.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Company &amp;lt; ActiveRecord::Base
  attr_accessible :name, :offices_attributes
  validates :name, presence: true
  has_many :offices
  accepts_nested_attributes_for :offices, allow_destroy: true, reject_if: :office_name_invalid

  private

    def office_name_invalid(attributes)
      # office name shouldn&#39;t start with underscore
      attributes[&#39;name&#39;] =~ /\A_/
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The method should return either true (rejects the record) or false.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; c.offices_attributes = [{ id: 1, name: &#39;_North America&#39;}]
&amp;gt;   =&amp;gt; [{:id=&amp;gt;1, :name=&amp;gt;&amp;quot;_North America&amp;quot;}]
&amp;gt; c.save
&amp;gt; c.offices # no changes
&amp;gt;   =&amp;gt; [#&amp;lt;Company::Office id: 1, company_id: 1, name: &amp;quot;North America&amp;quot;, created_at: &amp;quot;2012-10-08 19:21:54&amp;quot;, updated_at: &amp;quot;2012-10-08 19:46:22&amp;quot;&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could use predefined &lt;code&gt;:all_blank&lt;/code&gt; symbol.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; c.offices_attributes = [{ name: &#39;&#39;}]
&amp;gt;   =&amp;gt; [{:name=&amp;gt;&amp;quot;&amp;quot;}]
&amp;gt; c.save
&amp;gt; c.offices # no changes
&amp;gt;   =&amp;gt; [#&amp;lt;Company::Office id: 1, company_id: 1, name: &amp;quot;North America&amp;quot;, created_at: &amp;quot;2012-10-08 19:21:54&amp;quot;, updated_at: &amp;quot;2012-10-08 19:46:22&amp;quot;&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Passing &lt;code&gt;:all_blank&lt;/code&gt; instead of a Proc will create a proc that will reject a record where all the attributes are blank excluding any value for &lt;code&gt;_destroy&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;validating-count-of-the-nested-attributes&#34;&gt;Validating count of the nested attributes&lt;/h3&gt;

&lt;p&gt;Lets add more complexity to our company model and say for example: it &lt;strong&gt;must have at least one
office&lt;/strong&gt; (we usually called it the main office).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Company &amp;lt; ActiveRecord::Base
  OFFICES_COUNT_MIN = 1

  attr_accessible :name, :offices_attributes
  validates :name, presence: true
  validate do
    check_offices_number
  end
  has_many :offices
  accepts_nested_attributes_for :offices, allow_destroy: true

  private

    def offices_count_valid?
      offices.count &amp;gt;= OFFICES_COUNT_MIN
    end

    def check_offices_number
      unless offices_count_valid?
        errors.add(:base, :offices_too_short, :count =&amp;gt; OFFICES_COUNT_MIN)
      end
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem here is that accepts_nested_attributes_for call destroy for child
objects &lt;strong&gt;AFTER&lt;/strong&gt; validation of the parent object. So the user is able to delete
an office. Of course, later, when the user will try to edit a company,
he/she will get an error - &amp;ldquo;Company should have at least one office.&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://homeonrails.com/images/posts/2012-10-08-validating-nested-associations-in-rails/flowchart.png&#34; alt=&#34;Flowchart of the validation process&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; c.offices_attributes = [{ id: 1, _destroy: &#39;1&#39; }]
&amp;gt;   =&amp;gt; [{:id=&amp;gt;1, :_destroy=&amp;gt;&amp;quot;1&amp;quot;}]
&amp;gt; c.save
&amp;gt; c.offices
&amp;gt;   =&amp;gt; []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You could try to use standard &lt;code&gt;length&lt;/code&gt; validator
(e.g. &lt;code&gt;validates :offices, length: { minimum: OFFICES_COUNT_MIN }&lt;/code&gt;), and it actually works,
but again, it does not take into account the fact that some of the records may
be marked for destruction.&lt;/p&gt;

&lt;p&gt;The things are getting a little tricky here.
To sort out the problem, we need to understand what &lt;code&gt;offices_attributes=&lt;/code&gt; method does.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# accepts_nested_attributes_for generates for us this method
def offices_attributes=(attributes)
  # @note the name of the method to call may vary depending on the type of association
  # @see https://github.com/rails/rails/blob/master/activerecord/lib/active_record/nested_attributes.rb#L285
  assign_nested_attributes_for_collection_association(:offices, attributes, mass_assignment_options)
end

def assign_nested_attributes_for_collection_association
  ...
  if !call_reject_if(association_name, attributes) # if the record passed
    # update a record with the attributes or marks it for destruction
    assign_to_or_mark_for_destruction(existing_record, attributes, options[:allow_destroy], assignment_opts)
  end
  ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see from the code above, our method marks offices records (with &lt;code&gt;_destroy&lt;/code&gt; attribute) for destruction.
When the company validates offices count, the offices relation includes &lt;strong&gt;all&lt;/strong&gt; the records.
So, all we need to do is to select only those records not marked for destruction.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Company &amp;lt; ActiveRecord::Base
  ...

  private

    def offices_count_valid?
      offices.reject(&amp;amp;:marked_for_destruction?).count &amp;gt;= OFFICES_COUNT_MIN
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we&amp;rsquo;ve got the actual number of the company&amp;rsquo;s offices. Therefore, we will get an error while trying to delete the last office in North America:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; c.offices_attributes = [{ id: 1, _destroy: &#39;1&#39; }]
&amp;gt;   =&amp;gt; [{:id=&amp;gt;1, :_destroy=&amp;gt;&amp;quot;1&amp;quot;}]
&amp;gt; c.save
&amp;gt; c.errors
&amp;gt;   =&amp;gt; #&amp;lt;ActiveModel::Errors:0x000000038fc840 @base=#&amp;lt;Company id: 1, name: &amp;quot;Mars LLC&amp;quot;, created_at: &amp;quot;2012-10-08 19:16:44&amp;quot;, updated_at: &amp;quot;2012-10-08 19:16:44&amp;quot;&amp;gt;, @messages={:base=&amp;gt;[&amp;quot;Company should have at least one office.&amp;quot;]}&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hopefully, in Rails 3 we are now able to write our own custom validators, so I&amp;rsquo;ve added &lt;a href=&#34;http://homeonrails.com/2012/10/associationcountvalidator&#34;&gt;one more for this case&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you know a better solution, don&amp;rsquo;t hesitate to &lt;a href=&#34;http://homeonrails.com/about.html&#34;&gt;contact me&lt;/a&gt; or simply leave a comment below.&lt;/p&gt;

&lt;h3 id=&#34;validating-presence-of-the-parent-object&#34;&gt;Validating presence of the parent object&lt;/h3&gt;

&lt;p&gt;The last thing I wanna share with you is how you can add &lt;code&gt;presence&lt;/code&gt; validator
to the parent association inside the nested model.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Company::Office &amp;lt; ActiveRecord::Base
  attr_accessible :company_id, :name

  validates :name, presence: true
  # add validator to company
  validates :company, presence: true

  belongs_to :company
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We want to be sure that the office always have a corresponding company. But this fails on creating a company.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; c = Company.create(name: &#39;Adidas America Inc&#39;, offices_attributes: [{ name: &#39;LS&#39; }])
&amp;gt;   =&amp;gt; #&amp;lt;Company id: nil, name: &amp;quot;Adidas America Inc&amp;quot;, created_at: nil, updated_at: nil&amp;gt;
&amp;gt; c.errors
&amp;gt;   =&amp;gt; #&amp;lt;ActiveModel::Errors:0x000000036387a8 @base=#&amp;lt;Company id: nil, name: &amp;quot;Adidas America Inc&amp;quot;, created_at: nil, updated_at: nil&amp;gt;, @messages={:&amp;quot;offices.company&amp;quot;=&amp;gt;[&amp;quot;can&#39;t be blank&amp;quot;]}&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The solution here is to use &lt;code&gt;inverse_of&lt;/code&gt; option. See the options section
in &lt;code&gt;belongs_to&lt;/code&gt;, &lt;code&gt;has_one&lt;/code&gt; or &lt;code&gt;has_many&lt;/code&gt; &lt;a href=&#34;http://apidock.com/rails/ActiveRecord/Associations/ClassMethods/belongs_to&#34;&gt;documentation&lt;/a&gt;.
Note: it does not work in combination with the &lt;code&gt;polymorphic&lt;/code&gt; option.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;class Company &amp;lt; ActiveRecord::Base
  ...
  has_many :offices, inverse_of: :company
  ...
end

class Company::Office &amp;lt; ActiveRecord::Base
  ...
  belongs_to :company, inverse_of: :offices
  ...
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we are able to create a company instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;&amp;gt; c = Company.create(name: &#39;Adidas America Inc&#39;, offices_attributes: [{ name: &#39;LS&#39; }])
&amp;gt;   =&amp;gt; #&amp;lt;Company id: 2, name: &amp;quot;Adidas America Inc&amp;quot;, created_at: &amp;quot;2012-10-09 07:36:07&amp;quot;, updated_at: &amp;quot;2012-10-09 07:36:07&amp;quot;&amp;gt;
&amp;gt; c.offices
&amp;gt;   =&amp;gt; #&amp;lt;Company::Office id: 6, company_id: 2, name: &amp;quot;LS&amp;quot;, created_at: &amp;quot;2012-10-09 07:36:07&amp;quot;, updated_at: &amp;quot;2012-10-09 07:36:07&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>